<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骄阳焦洋</title>
  
  <subtitle>明明如月，何时可掇？忧从中来，不可断绝。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jy3321.github.io/"/>
  <updated>2021-02-02T15:10:47.136Z</updated>
  <id>https://jy3321.github.io/</id>
  
  <author>
    <name>焦洋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日学习</title>
    <link href="https://jy3321.github.io/2021/02/02/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jy3321.github.io/2021/02/02/每日学习/</id>
    <published>2021-02-02T15:02:53.000Z</published>
    <updated>2021-02-02T15:10:47.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020-02-02"><a href="#2020-02-02" class="headerlink" title="2020.02.02"></a>2020.02.02</h1><h2 id="1-java基础语法"><a href="#1-java基础语法" class="headerlink" title="1.java基础语法"></a>1.java基础语法</h2><h3 id="1-java是一种跨平台的纯面向对象的语言，而-Net是一种跨语言的平台"><a href="#1-java是一种跨平台的纯面向对象的语言，而-Net是一种跨语言的平台" class="headerlink" title="1.java是一种跨平台的纯面向对象的语言，而.Net是一种跨语言的平台"></a>1.java是一种跨平台的纯面向对象的语言，而.Net是一种跨语言的平台</h3><p>​    对照关系应该为<br>​    Java：语言        JDK：平台<br>​    C#：语言        .Net：平台<br>即通常我们所说的语言，都是指的语言本身，而.Net 的语言是指的平台，.Net用的语言是C#,也就是说C#和.Net是一个东西，不要问学C#好还是.Net好这样让人笑话的问题。</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2020-02-02&quot;&gt;&lt;a href=&quot;#2020-02-02&quot; class=&quot;headerlink&quot; title=&quot;2020.02.02&quot;&gt;&lt;/a&gt;2020.02.02&lt;/h1&gt;&lt;h2 id=&quot;1-java基础语法&quot;&gt;&lt;a href=&quot;#1-java基础语法&quot;
      
    
    </summary>
    
      <category term="学习日记" scheme="https://jy3321.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="学习日记" scheme="https://jy3321.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>git bash中的快捷键</title>
    <link href="https://jy3321.github.io/2020/10/04/git-bash%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://jy3321.github.io/2020/10/04/git-bash中的快捷键/</id>
    <published>2020-10-04T03:22:19.000Z</published>
    <updated>2020-10-05T05:36:10.914Z</updated>
    
    <content type="html"><![CDATA[<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li><p><code>pwd</code> (Print Working Directory) 查看当前目录</p></li><li><p><code>cd</code> (Change Directory) 切换目录，如 cd /etc</p></li><li><p><code>ls (List)</code> 查看当前目录下内容，如 ls -al</p></li><li><p><code>mkdir</code> (Make Directory) 创建目录，如 mkdir blog</p></li><li><p><code>touch</code> 创建文件，如 touch index.html</p></li><li><p><code>cat</code> 查看文件全部内容，如 cat index.html</p></li><li><p><code>more/less</code> 查看文件，如more /etc/passwd、less /etc/passwd</p></li><li><p><code>rm (remove)</code> 删除文件，如 rm index.html、rm -rf  blog</p></li><li><p><code>rmdir</code> (Remove Directory) 删除文件夹，只能删除空文件夹，不常用</p></li><li><p><code>mv</code> (move) 移动文件或重命名，如 mv index.html ./demo/index.html</p></li><li><p><code>cp</code> (copy) 复制文件，cp index.html ./demo/index.html</p></li><li><p><code>head</code> 查看文件前几行，如 head -5 index.html</p></li><li><p><code>tail</code> 查看文件后几行 –n –f，如 tail index.html、tail -f -n 5 index.html</p></li><li><p><code>tab</code> 自动补全，连按两次会将所有匹配内容显示出来</p></li><li><p><code>history</code> 查看操作历史</p></li><li><p><code>\&gt;</code> 和<code>&gt;&gt;</code>重定向，如echo hello world! &gt; README.md，&gt;覆盖 &gt;&gt;追加</p></li><li><p><code>wget</code> 下载，如wget <a href="https://nodejs.org/dist/v4.4.0/node-v4.4.0.tar.gz" target="_blank" rel="noopener">https://nodejs.org/dist/v4.4.0/node-v4.4.0.tar.gz</a></p></li><li><p><code>tar</code> 解压缩，如tar zxvf node-v4.4.0.tar.gz</p></li><li><p><code>curl</code> 网络请求，如curl <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></p></li><li><p><code>whoami</code> 查看当前用户</p></li><li><p><code>|</code> 管道符可以将多个命令连接使用，上一次（命令）的执行结果当成下一次（命令）的参数。</p></li><li><p><code>grep</code> 匹配内容，一般结合管道符使用</p></li></ul><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><h3 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h3><p>ctrl+b 前移至一个字符(backward)<br>ctrl+f 后移至一个字符(forward)<br>alt+b 前移至一个单词<br>alt+f 后移至一个单词<br>ctrl+a 跳转至行首<br>ctrl+e 跳转至行尾<br>ctrl+x 行首/当前位置光标跳转</p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>alt+. 粘帖上一次命令最后的参数<br>ctrl+h 删除光标前一个字符（backspace）<br>ctrl+d 删除光标后一个字符（delete）<br>ctrl+w 删除光标左侧单词<br>alt+d 删除光标右侧单词<br>ctrl+u 删除光标左侧所有字符<br>ctrl+k 删除光标右侧所有字符<br>ctrl+l 清屏<br>ctrl+shift+c 复制(ctrl+ins)<br>ctrl+shift+v 粘贴(shift+ins)</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p>ctrl+n 下一条命令<br>ctrl+p 上一条命令<br>shift+PageUp 向上翻页<br>shift+PageDown 向下翻页<br>ctrl+r 查找命令历史记录，输入keyword多次ctrl+r可返回下一个匹配项</p><p>touch 新建文件<br>mkdir 新建目录<br>rm 删除文件<br>rm -r 删除文件夹(recusive)<br>mv 移动文件<br>ls 列出文件<br>pwd 打印工作目录<br>cd 改变目录<br>reset 清屏</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;pwd&lt;/code&gt; (Print Working Directory) 查看当前目录&lt;/p&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Git" scheme="https://jy3321.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://jy3321.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>SQL Server常用语句记录</title>
    <link href="https://jy3321.github.io/2020/10/03/SQL-Server%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95/"/>
    <id>https://jy3321.github.io/2020/10/03/SQL-Server常用语句记录/</id>
    <published>2020-10-03T11:00:41.000Z</published>
    <updated>2021-05-04T04:14:50.559Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>新的工作跟数据库接触的比较多，而且主要是SQL Server，在此记录一些常用的操作和查询方法，便于日后复习使用。</p><h3 id="临时表的建法"><a href="#临时表的建法" class="headerlink" title="临时表的建法"></a>临时表的建法</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * into #临时表名 from 你的表;</span><br><span class="line">select * into ##临时表名 from 你的表;</span><br></pre></td></tr></table></figure><p>注：以上的#代表局部临时表，##代表全局临时表</p><h3 id="查询字段第几个字是某个指定字符"><a href="#查询字段第几个字是某个指定字符" class="headerlink" title="查询字段第几个字是某个指定字符"></a>查询字段第几个字是某个指定字符</h3><p>可用substring函数来查询；<br>如：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/10/03/SQL-Server常用语句记录/001.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>现在要查询第二位zhi字符为“s”的数据，dao可用如下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="function">from test where <span class="title">substring</span><span class="params">(STR,<span class="number">2</span>,<span class="number">1</span>)</span></span>=<span class="string">'s'</span></span><br></pre></td></tr></table></figure><p>结果截图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/10/03/SQL-Server常用语句记录/002.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>substring函数说明：<br>substring函数需要三个参数，其中第一个参数是要截取的字符串，第二个参数是要查询字符串的起始位，第三个参数为截取的字符长度。</p><h3 id="查询某个表所有的列名"><a href="#查询某个表所有的列名" class="headerlink" title="查询某个表所有的列名"></a>查询某个表所有的列名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from syscolumns where id = object_id(<span class="string">'表名'</span>);</span><br></pre></td></tr></table></figure><p>也可以计算列的个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">count</span><span class="params">(name)</span> from syscolumns where id </span>= object_id(<span class="string">'表名'</span>);</span><br></pre></td></tr></table></figure><h3 id="变量的声明、设置、使用、输出"><a href="#变量的声明、设置、使用、输出" class="headerlink" title="变量的声明、设置、使用、输出"></a>变量的声明、设置、使用、输出</h3><p>声明了三个变量：typeid、parentid、name，数据类型分别为：int、int、varchar(50)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="meta">@typeid</span> <span class="keyword">int</span>,<span class="meta">@parentid</span> <span class="keyword">int</span>,<span class="meta">@name</span> varchar(<span class="number">50</span>) ;</span><br></pre></td></tr></table></figure><p>设置变量：name 的值为：成都市</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set <span class="meta">@name</span>=<span class="string">'成都市'</span>;</span><br></pre></td></tr></table></figure><p>使用变量，变量查询赋值：使用 @name 变量，将查询出来的 typeid 字段的数据赋值给 @typeid 变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="meta">@typeid</span> = typeid from [logging].[dbo].[SYS_CODE] where name = <span class="meta">@name</span>;</span><br></pre></td></tr></table></figure><p>使用下面的代码直接输出变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print  <span class="string">'typeid：'</span>+<span class="meta">@typeid</span>+<span class="string">'   name：'</span>+ <span class="meta">@name</span></span><br></pre></td></tr></table></figure><p>SQL Server 报错：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/10/03/SQL-Server常用语句记录/003.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这是因为SQL Server 不能直接将 int 类型的数据转换为 varchar ，使用 cast 可以进行类型转换：<br>-@typeid 转换的变量/数据 as varchar转换的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast(<span class="meta">@typeid</span> <span class="function">as <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span>)</span></span><br></pre></td></tr></table></figure><p>写成下面这样就可以正常输入结果了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print  <span class="string">'typeid：'</span>+cast(<span class="meta">@typeid</span> <span class="function">as <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span>) +'   name：'+ @name</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/10/03/SQL-Server常用语句记录/004.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="declare的用法（非局部变量，在批处理中仍有用）"><a href="#declare的用法（非局部变量，在批处理中仍有用）" class="headerlink" title="declare的用法（非局部变量，在批处理中仍有用）"></a>declare的用法（非局部变量，在批处理中仍有用）</h3><p>平时写SQL查询、存储过程都是凭着感觉来，没有探究过SQL的具体语法，一直都是按以前一套往SQL上模仿，前几天项目中碰到一个问题引起了我对declare定义变量的作用域的兴趣。<br>局部变量，在if中如果我们定义一个变量的话他的作用到if结束为止，if外是不识别这个变量的，else里都不能使用，简单的写一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">Int32 i = <span class="number">1</span>;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个i的作用域就是if里面，如果我们在if外面用这个变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">Int32 i = <span class="number">1</span>;</span><br><span class="line">Console.WriteLine(i);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(i);</span><br></pre></td></tr></table></figure><p>那第二条输出语句会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The name <span class="string">'i'</span> does not exist in the current context</span><br></pre></td></tr></table></figure><p>说明已经出了i的作用域了。<br>那么我们要是在sql写这么一段代码会是什么情况呢？首先写在if内 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IF <span class="number">1</span>=<span class="number">1</span></span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE <span class="meta">@test</span> VARCHAR</span><br><span class="line">    SET <span class="meta">@test</span>=<span class="string">'1'</span>   </span><br><span class="line">    PRINT <span class="string">'in if:'</span>+<span class="meta">@test</span></span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>运行看结果输出in if:1这是可以预想的结果。那我们在if外面使用变量@test试试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF <span class="number">1</span>=<span class="number">1</span></span><br><span class="line">BEGIN</span><br><span class="line">   DECLARE <span class="meta">@test</span> VARCHAR</span><br><span class="line">   SET <span class="meta">@test</span>=<span class="string">'1'</span>   </span><br><span class="line">   PRINT <span class="string">'in if:'</span>+<span class="meta">@test</span></span><br><span class="line">END</span><br><span class="line">PRINT <span class="string">'out if:'</span>+<span class="meta">@test</span></span><br></pre></td></tr></table></figure><p>这样会是什么结果呢，不知道大家怎么想的，以我的大脑顺势就想到这应该报错啊，出了变量的作用域了。实际结果不仅没报错而且@test的值还在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in <span class="keyword">if</span>:<span class="number">1</span></span><br><span class="line">out <span class="keyword">if</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure><p>看见这个结果当时我很郁闷，SQL太出人意料了。<br>在SQL SERVER 2005的帮助文档里关于declare的帮助里发现这么一句话，备注的第三行“局部变量的作用域是其被声明时所在批处理”<br>Msdn的地址：<a href="http://msdn.microsoft.com/zh-cn/library/ms188927.aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/zh-cn/library/ms188927.aspx</a><br>这行字在这么一大篇中还真挺不引人瞩目。<br>现在我们知道原来declare变量的作用域是所在的批处理，if阻断不了它的作用域，那上面我们的代码if内外的代码都在一个批处理中，所以@test都是可用的且if里面设置的值还在。<br>下面我改造一下代码，SQL中是以GO语句来区分批处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IF <span class="number">1</span>=<span class="number">1</span></span><br><span class="line">BEGIN</span><br><span class="line">   DECLARE <span class="meta">@test</span> VARCHAR</span><br><span class="line">   SET <span class="meta">@test</span>=<span class="string">'1'</span>   </span><br><span class="line">   PRINT <span class="string">'in if:'</span>+<span class="meta">@test</span></span><br><span class="line">END</span><br><span class="line">GO</span><br><span class="line">PRINT <span class="string">'out if:'</span>+<span class="meta">@test</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/10/03/SQL-Server常用语句记录/005.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这样就会报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;新的工作跟数据库接触的比较多，而且主要是SQL Server，在此记录一些常用的操作和查询方法，便于日后复习使用。&lt;/p&gt;

      
    
    </summary>
    
      <category term="SQL Server" scheme="https://jy3321.github.io/categories/SQL-Server/"/>
    
    
      <category term="SQL" scheme="https://jy3321.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>重启大法好（记最近一件又蠢又好笑的事）</title>
    <link href="https://jy3321.github.io/2020/05/10/%E9%87%8D%E5%90%AF%E5%A4%A7%E6%B3%95%E5%A5%BD%EF%BC%88%E8%AE%B0%E6%9C%80%E8%BF%91%E4%B8%80%E4%BB%B6%E5%8F%88%E8%A0%A2%E5%8F%88%E5%A5%BD%E7%AC%91%E7%9A%84%E4%BA%8B%EF%BC%89/"/>
    <id>https://jy3321.github.io/2020/05/10/重启大法好（记最近一件又蠢又好笑的事）/</id>
    <published>2020-05-10T06:52:36.000Z</published>
    <updated>2020-05-10T07:08:13.604Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上自己项目好好的，今天跑的时候，项目一运行主页就是自己的页面找不到了的页面，由于之前项目刚在本地运行的时候也出现过这样的问题，就怀疑是数据库配置有问题，反复改了很多次，甚至把项目重新导入从头重新建配置，反复多次尝试多种方式，无果。后来直接去看看数据库。打开Navicat时发现报错ERROR 2013：Lost connection to MySQL server，意思就是我数据库都连接不上了？ ？去网上查了这个报错怎么解决，方法试了都无果，知道看到一篇帖子里的说法：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/05/10/重启大法好（记最近一件又蠢又好笑的事）/2ef28f49717aa3c98ea057eb735bb41" alt title>                </div>                <div class="image-caption"></div>            </figure><p>跟我一样，各种方法尝试无果，然后，重启？？<br>行吧我试一下，卧槽？？<br>好吧就是这样，重启一下电脑项目就能正常访问数据库，显示内容了。</p><p>就这样一个问题让我郁闷了一早上，自己真的是又想笑又无奈。也该反思一下自己是不是学傻了，思维都固化了，明明前一天晚上可以运行，就说明代码没有问题，今天出问题应该从环境上找问题，而不是怀疑自己去改自己的配置和代码。。</p><p>记得之前去看摩天营救的时候，整部电影啥都没记住，就记住了那句重启就好了的梗。没想到今天自己也成了这个梗。嗯，以后要记得，重启大法好。哈哈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天晚上自己项目好好的，今天跑的时候，项目一运行主页就是自己的页面找不到了的页面，由于之前项目刚在本地运行的时候也出现过这样的问题，就怀疑是数据库配置有问题，反复改了很多次，甚至把项目重新导入从头重新建配置，反复多次尝试多种方式，无果。后来直接去看看数据库。打开Navica
      
    
    </summary>
    
      <category term="日常" scheme="https://jy3321.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="日常" scheme="https://jy3321.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>常用数据库JDBC驱动名称及URL</title>
    <link href="https://jy3321.github.io/2020/05/10/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93JDBC%E9%A9%B1%E5%8A%A8%E5%90%8D%E7%A7%B0%E5%8F%8AURL/"/>
    <id>https://jy3321.github.io/2020/05/10/常用数据库JDBC驱动名称及URL/</id>
    <published>2020-05-10T06:46:36.000Z</published>
    <updated>2020-05-10T06:49:30.402Z</updated>
    
    <content type="html"><![CDATA[<p>为方便使用JDBC连接各种数据库，特对常用的数据库driverClassName和url进行整理，方便自己查阅和使用。</p><p><img src="/2020/05/10/常用数据库JDBC驱动名称及URL/385309935.png" alt></p><p>需要注意的是MySQL版本不同驱动和URL也不一致，并且MySQL 6.0 及其以上的版本url后面必须加上参数<strong>serverTimezone=UTC</strong>；不加则会报错。</p><p>除此之外还可选加参数(多个参数之间用&amp;连接)：<code>useUnicode=true</code>；<code>characterEncoding=utf8</code> ; <code>useSSL=false</code>,但一般建议加上，如果不加useSSL不会出错但有警告。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为方便使用JDBC连接各种数据库，特对常用的数据库driverClassName和url进行整理，方便自己查阅和使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/05/10/常用数据库JDBC驱动名称及URL/385309935.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;需要注
      
    
    </summary>
    
      <category term="数据库" scheme="https://jy3321.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://jy3321.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>最近二三事</title>
    <link href="https://jy3321.github.io/2019/11/26/twoOrThreeRecentEvents/"/>
    <id>https://jy3321.github.io/2019/11/26/twoOrThreeRecentEvents/</id>
    <published>2019-11-26T11:57:13.000Z</published>
    <updated>2020-05-10T07:09:53.687Z</updated>
    
    <content type="html"><![CDATA[<p>其实最近有一段时间没有捣鼓自己的博客了，各种原因吧，自己反省了一下最近这段时间做的事，感觉自己又把最宝贵的时间浪费了过去。。写点东西总结一下最近的自己吧。</p><p>几个月前，自己满心欢喜的搭建起了这个博客，然后特别特别的想让自己的博客里有文章，就去看别人的博客，学着写东西，有些内容自己甚至不是很理解，觉得别人写的特别好就写在了自己的博客里，觉得很有成就感很有满足感，但是完全忘记了自己搭建这个博客的最初目的——记录自己的学习，帮助自己更好的学习。因为有些内容自己现在看甚至都已经忘记了当时为什么那样总结为什么那样写，只是当时为了写博客而写的，并没有深入的去理解去学习，比如之前明明有看了内存模型相关的知识甚至写了博客，在面试字节的时候被问到回答的还是一塌糊涂，甚至在问到类加载机制的时候，我竟然忘了static初始化顺序，简单的一道判断初始化顺序的题也能回答错误（不知道当时面试官是不是都想嘲笑我…反正我觉得自己当时好丢人…static是在类被初始化的时候执行的，java初始化正确的顺序应该是：父类静态成员变量→父类静态代码块→子类静态成员变量→子类静态代码块→父类非静态成员变量→父类非静态代码块→父类构造函数→子类非静态成员变量→子类非静态代码块→子类构造函数）。自己光顾着看光顾着写，而忘记了更重要的要自己去理解去思考。在秋招经历了几个大厂的惨烈面试之后，我自闭了很久。自己差的真的太多了，除了基础知识差，要补充要学习的东西也真的太多，以至于在后面的面试，我都没有信心再去参加面试，自己一度放弃了秋招。。</p><p>一直到最近一个月，和自己一起开始准备秋招的室友，拿到了offer，工资极其可观诱人，酸死了。。看看人家，在酸的同时，仿佛又给自己打了鸡血，同样都是一个学校一个班甚至一个宿舍的，他能做到，我为什么不能做到。也就是最近开始，自己才又开始正视自己的问题，去LeetCode上刷题，去牛客上看面经，拿出以前买的书一页一页的看，正如室友讲的，学就完事了，血本有归就行。也许秋招真的要错过了，但是努力，应该会有结果的。</p><p>自己这段时间又对博客感兴趣起来了，想重新尝试下别的框架搭博客，觉Hexo没有后台没有自带的文章编辑器，使用起来好像没那么方便？原来觉得好看的排版和主题，现在看起来好像也没那么顺眼了？想试试Hago和WordPress？？好像Unity也蛮好玩的，自己也想试试学着做小游戏？？？。。。可是要找工作啊大哥！在秋招的时候发现一堆好玩的东西，我发现自己老是在一些关键时刻发现一些好玩有意思的事，然后去分心影响正事，为什么没早点发现啊。不过还要吐槽一下学校，大四了还是满课，课程作业全是报告，上万字的那种，然后还有各种各样的图。。无奈。争取把这段时间熬过去吧，秋招让我太痛苦了。后面调整好心态继续努力复习，刷题看知识点，看看秋招补录，实在不行准备春招，自己多准备准备应该也会有机会的吧。抽空把课程作业补完，最近可能不太更新自己的博客了，如果要更，也要保证后面更新的东西都会是自己思考理解了的东西再进行更新。后面可能会重新搭一下博客，如果找工作能顺利一点的话，我是说如果，再慢慢捣鼓吧。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实最近有一段时间没有捣鼓自己的博客了，各种原因吧，自己反省了一下最近这段时间做的事，感觉自己又把最宝贵的时间浪费了过去。。写点东西总结一下最近的自己吧。&lt;/p&gt;
&lt;p&gt;几个月前，自己满心欢喜的搭建起了这个博客，然后特别特别的想让自己的博客里有文章，就去看别人的博客，学着写
      
    
    </summary>
    
      <category term="日常" scheme="https://jy3321.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="日常" scheme="https://jy3321.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>快速理解UML类图中各个类之间的关系</title>
    <link href="https://jy3321.github.io/2019/11/22/UMLclass/"/>
    <id>https://jy3321.github.io/2019/11/22/UMLclass/</id>
    <published>2019-11-22T02:55:25.000Z</published>
    <updated>2020-05-10T07:11:18.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从一个示例开始"><a href="#从一个示例开始" class="headerlink" title="从一个示例开始"></a>从一个示例开始</h3><hr><p>我们通过一个例子来理解</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/22/UMLclass/uml_class_struct.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>车的类图结构为&lt; abstract &gt;，表示车是一个抽象类；</li><li>它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；</li><li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；</li><li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；</li><li>学生与班级之间是聚合关系，使用带空心箭头的实线表示；</li><li>学生与身份证之间为关联关系，使用一根实线表示；</li><li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</li></ul><p>下面我们将介绍这六种关系；</p><hr><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><hr><h4 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h4><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：</p><p>继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p><p>eg：自行车是车、猫是动物</p><p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/22/UMLclass/uml_generalization.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/22/UMLclass/uml_generalize.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>注：最终代码中，泛化关系表现为继承非抽象类；</p><h4 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h4><p>实现关系用一条带空心箭头的虚线表示；</p><p>eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/22/UMLclass/uml_realize.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>注：最终代码中，实现关系表现为继承抽象类；</p><h4 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h4><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/22/UMLclass/uml_aggregation.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p><h4 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h4><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/22/UMLclass/uml_composition.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p><h4 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h4><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/22/UMLclass/uml_association.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p><h4 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h4><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/22/UMLclass/uml_dependency.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p><hr><p>感谢：<a href="https://design-patterns.readthedocs.io/" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;从一个示例开始&quot;&gt;&lt;a href=&quot;#从一个示例开始&quot; class=&quot;headerlink&quot; title=&quot;从一个示例开始&quot;&gt;&lt;/a&gt;从一个示例开始&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;我们通过一个例子来理解&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
      
    
    </summary>
    
      <category term="UML" scheme="https://jy3321.github.io/categories/UML/"/>
    
    
      <category term="UML" scheme="https://jy3321.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>值得你读的博客（一起挖宝吧）</title>
    <link href="https://jy3321.github.io/2019/09/08/blogsURL/"/>
    <id>https://jy3321.github.io/2019/09/08/blogsURL/</id>
    <published>2019-09-08T10:50:51.000Z</published>
    <updated>2019-11-22T03:26:32.916Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>在学习的过程中挖到了大量的宝贝。。。。话不多说，在这里跟大家分享一下目前挖到的宝，后续再发现比较好的博客会持续更新一起学习加油吧！</code></pre><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>五月的仓颉是我第一个关注的博主，大佬的文章勾起了我想自己写博客的欲望<br><a href="https://www.cnblogs.com/xrq730/" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/</a></li><li>JavaGuide ，github上优秀的java知识总结，我自己目前也在跟着学习和复习<br><a href="https://snailclimb.gitee.io/javaguide/#/" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/</a></li><li>图说设计模式<br><a href="https://design-patterns.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/zh_CN/latest/</a></li><li>Java成神之路技术整理<br><a href="https://my.oschina.net/javaroad/blog/1793570" target="_blank" rel="noopener">https://my.oschina.net/javaroad/blog/1793570</a></li><li>白话算法系列的作者<br><a href="https://blog.csdn.net/MoreWindows/article/details/6657829" target="_blank" rel="noopener">https://blog.csdn.net/MoreWindows/article/details/6657829</a></li><li>菜鸟联盟，这个应该不算是博客，而是一个比较好的网站吧，应该大家在搜索某些知识的时候多多少少都打开过。各种基础知识都可以在上面学习，他还提供了很多小工具，比如在线编辑器等，都很好用<br><a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a></li><li>java各种基础知识点的汇总<br><a href="https://www.cnblogs.com/qdhxhz/default.html?page=2" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/default.html?page=2</a></li><li>java进阶合集<br><a href="https://blog.csdn.net/sunhuaqiang1/article/category/3130685" target="_blank" rel="noopener">https://blog.csdn.net/sunhuaqiang1/article/category/3130685</a></li><li>关于jvm可以看看这个博客<br><a href="http://hllvm.group.iteye.com/group/wiki/?category_id=316" target="_blank" rel="noopener">http://hllvm.group.iteye.com/group/wiki/?category_id=316</a></li><li>Intellij Idea相关的各种使用相关问题，从注册到开发，基本配置，如何配置使用方便，等等很多实用的小技巧及使用过程中产生的各种各样的问题<br><a href="https://blog.csdn.net/column/details/15222.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/15222.html</a></li><li>关于java的IO可以看这个<br><a href="http://ifeve.com/java-io/" target="_blank" rel="noopener">http://ifeve.com/java-io/</a></li><li>多线程，集合，I/O和异常等可以看这个博客，而且都是系列化的文章，对于我这种推崇系统化学习的人来说，真的很不错<br><a href="http://www.cnblogs.com/skywang12345/category/455711.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/category/455711.html</a></li><li>超简单的 MySQL 数据库教程<br><a href="https://blog.csdn.net/column/details/16138.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/16138.html</a></li><li>关于Spring的几篇文章写得很详细，阅读量很高<br><a href="https://blog.csdn.net/lutianfeiml" target="_blank" rel="noopener">https://blog.csdn.net/lutianfeiml</a></li><li>快速学习 Spring Boot 技术栈<br><a href="https://blog.csdn.net/column/details/15149.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/15149.html</a></li><li>介绍maven基础以及扩展知识<br><a href="https://blog.csdn.net/column/details/maven-force.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/maven-force.html</a></li><li>主要集中在Java Web本身的技术解释和剖析，不涉及任何框架的技术<br><a href="https://blog.csdn.net/column/details/15759.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/15759.html</a></li><li>设计模式是一个程序员迟早要掌握的技能<br><a href="https://blog.csdn.net/column/details/pattern.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/pattern.html</a></li><li>CSDN排名第七，神一样的人物<br><a href="https://blog.csdn.net/notbaron/article/category/6026793" target="_blank" rel="noopener">https://blog.csdn.net/notbaron/article/category/6026793</a></li><li>这绝对是java大神级别的人物，java学习者必须关注<br><a href="https://blog.csdn.net/sunhuaqiang1/article/category/3130685" target="_blank" rel="noopener">https://blog.csdn.net/sunhuaqiang1/article/category/3130685</a></li><li>《成神之路系列文章》系列作者，阿里大神Hollis的博客怎么可以错过<br><a href="http://www.hollischuang.com/archives/1001" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1001</a></li><li>分享技术，品味人生，来自纯洁的微笑，学习SpringBoot和Cloud必须关注的博客<br><a href="http://www.ityouknow.com/" target="_blank" rel="noopener">http://www.ityouknow.com/</a></li><li>学习设计模式，这是很好的一个博客<br><a href="http://www.cnblogs.com/java-my-life/" target="_blank" rel="noopener">http://www.cnblogs.com/java-my-life/</a></li><li>java编程及工程的一些话题<br><a href="https://www.cnblogs.com/qdhxhz/default.html?page=2" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/default.html?page=2</a></li></ul><p><strong>（未完待续，持续更新）</strong></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在学习的过程中挖到了大量的宝贝。。。。
话不多说，在这里跟大家分享一下目前挖到的宝，后续再发现比较好的博客会持续更
      
    
    </summary>
    
      <category term="Blogs" scheme="https://jy3321.github.io/categories/Blogs/"/>
    
    
      <category term="Blogs" scheme="https://jy3321.github.io/tags/Blogs/"/>
    
  </entry>
  
  <entry>
    <title>JSP页面之间传值的方法总结</title>
    <link href="https://jy3321.github.io/2019/09/04/JSPPassing/"/>
    <id>https://jy3321.github.io/2019/09/04/JSPPassing/</id>
    <published>2019-09-04T01:07:33.000Z</published>
    <updated>2019-09-04T02:34:31.991Z</updated>
    
    <content type="html"><![CDATA[<h3 id="B-S页面间通信"><a href="#B-S页面间通信" class="headerlink" title="B/S页面间通信"></a>B/S页面间通信</h3><hr><p>HTTP是无状态的协议。Web页面本身无法向下一个页面传递信息，如果需要让下一个页面得知该页面中的值，除非通过服务器。因此，Web页面保持状态并传递给其它页面，是一个重要的技术。</p><p>Web页面之间传递数据，是Web程序的重要功能，需要：<br><strong>客户端界面（输入信息） → 发送数据 → 服务器 → 响应 → 客户端界面（显示信息）</strong></p><p>在HTTP协议中一共有 <strong>4</strong>种方法来完成这件事情：</p><ol><li>URL传值；</li><li>表单传值；</li><li>Cookie方法；</li><li>Session方法；</li></ol><hr><h3 id="URL传值"><a href="#URL传值" class="headerlink" title="URL传值"></a>URL传值</h3><hr><p><strong>优点：</strong><br>简单性和平台支持的多样性（浏览器都支持URL）。<br><strong>缺点：</strong></p><ul><li>传输的数据只能是字符串，对数据类型具有一定的限制；</li><li>传输数据的值会在浏览器地址栏里面被看到，从保密的角度讲，这是不安全的。特别是秘密性要求比较严格的数据，比如说密码。</li></ul><hr><h3 id="表单传值"><a href="#表单传值" class="headerlink" title="表单传值"></a>表单传值</h3><hr><p><strong>优点</strong><br>URL中不会被看到<br><strong>缺点</strong></p><ol><li>和URL方法类似，该方法传输的数据，也只能是字符串，对数据类型具有一定的限制；</li><li>传输数据的值虽然可以保证在浏览器地址栏里不被看到，但是在客户端源代码里面也会被看到，从保密的角度讲，这是不安全的。对于是秘密性要求比较严格的数据，比如说密码来说还是不建议用表单来进行传输。</li></ol><hr><h3 id="Cookie方法"><a href="#Cookie方法" class="headerlink" title="Cookie方法"></a>Cookie方法</h3><hr><p>Cookie是一个小的文本数据，由服务器端生成，发送给客户端浏览器，客户端浏览器如果设置为启用 cookie，则会将这个小文本数据保存到其目录下的文本文件内。客户端下次登录同一网站，浏览器则会自动将 Cookie 读入之后，传给服务器端。服务器端可以对该 Cookie 进行读取并验证(当然也可以不读取)。</p><p>一般情况下，Cookie 中的值是以key-value的形式进行表达的。页面间的传值可以用 Cookie来进行。即：在第一个页面中，将要共享的变量值保存在客户端 Cookie 文件内，在客户端访问第二个页面时，由于浏览器自动将 Cookie读入之后，传给服务器端，因此只需要第二个页面中，由服务器端页面读取这个 Cookie 值即可。</p><p><strong>问题</strong></p><p>在客户端的浏览器上，我们看不到任何的和传递的值相关的信息，说明在客户端浏览器中，Cookie 中的数据是安全的。</p><p>但是就此也不能说 Cookie 是完全安全的。因为 Cookie 是以文件形式保存在客户端的，客户端存储的 Cookie 文件就可能敌方获知。如果将用户名、密码等敏感信息保存在Cookie内，在用户离开客户机时不注意清空，这些信息容易泄露，因此Cookie在保存敏感信息方面具有潜在危险。可以很清楚地看到。</p><p>Cookie的危险性来源于Cookie的被盗取。目前盗取的方法有多种：</p><ul><li>利用跨站脚本技术，将信息发给目标服务器；为了隐藏跨站脚本的 URL，甚至可以结合 Ajax(异步Javascript 和 XML技术)在后台窃取 Cookie；</li><li>通过某些软件，窃取硬盘下的 Cookie。如前所述，当用户访问完某站点后，Cookie文件会存在机器的某个文件夹(如 C:\Documents and Settings\用户名\Cookies)下，因此可以通过某些盗取和分析软件来盗取 Cookie。<pre><code>具体步骤如下：(1)利用盗取软件分析系统中的 Cookie，列出用户访问过的网站；(2)在这些网站中寻找攻击者感兴趣的网站；(3)从该网站的 Cookie 中获取相应的信息。不同的软件有不同的实现方法，有兴趣的读者可以在网上搜索相应的软件；</code></pre></li><li>利用客户端脚本盗取 Cookie。在 Javascript 中有很多 API 可以读取客户端 Cookie，可以将这些代码隐藏在一个程序(如画图片)中，很隐秘地得到 Cookie 的值，不过，这也是跨站脚本的一种实现方式。<br>以上的问题并不能代表Cookie就没有任何用处，Cookie在Web编程中应用的几个方面：<ul><li>Cookie 的值能够持久化，即使客户端机器关闭，下次打开还是可以得到里面的值。因此 Cookie 可以用来减轻用户一些验证工作的输入负担，比如用户名和密码的输入，就可以在第一次登录成功之后，将用户名和密码保存在客户端 Cookie，下次不用输入。当然，这不安全，但是，对于一些安全要求不高的网站，Cookie 还是大有用武之地。</li><li>Cookie可以帮助服务器端保存多个状态信息，但是不用服务器端专门分配存储资源，减轻了服务器端的负担。比如网上商店中的购物车，必须将物品和具体客户名称绑定，但是放在服务器端又需要占据大量资源的情况下，可以用 Cookie 来实现，将每个物品和客户的内容作为 Cookie 来保存在客户端。</li><li>Cookie可以持久保持一些和客户相关的信息。如很多网站上，客户可以自主设计自己的个性化主页，其作用是避免用户每次都需要自己去找自己喜爱的内容，设计好之后，下次打开该网址，主页上显示的是客户设置好的界面。这些设置信息保存在服务器端的话，消耗服务器端的资源，因此，可以将客户的个性化设计保存在 Cookie 内，每一次访问该主页，客户端将 Cookie 发送给服务器端，服务器根据 Cookie 的值来决定显示给客户端什么样的界面。</li></ul></li></ul><p><strong>解决Cookie安全问题</strong></p><ul><li>替代cookie。将数据保存在服务器端，可选的是session方案；</li><li>及时删除cookie，设置失效时间；</li></ul><hr><h3 id="Session方法"><a href="#Session方法" class="headerlink" title="Session方法"></a>Session方法</h3><hr><p><strong>与前三种方法的区别</strong></p><p>前几种方法在传递数据时，有一个共同的问题就是内容保存在客户端里。因此，具有泄露的危险性。如果在不考虑服务器负载的情况下，将数据保存在服务端里，是一个比较好的方法，这就是session方法。<br>通过session.setAttribute(“num”,str);将str存到session中，通过session.getAttribute(“num”);从session中获取num</p><p><strong>服务器如何知道要分配给它的是同一个 session 对象？</strong></p><p>在客户进行第一次访问时，服务器端就给 session 分配了一个 sessionId，并且让客户端记住了这个 sessionId，客户端访问下一个页面时，又将 sessionId 传送给服务器端，服务器端根据这个 sessionId 来找到前一个页面用的 session，由此保证为同一个客户服务的 session 对象是同一个。</p><p><strong>session 分配的具体过程：</strong></p><ol><li>客户端访问服务器，服务器使用 session，首先检查这个客户端的请求里是否已包含了 sessionId；</li><li>如果有，服务器就在内存中检索相应 Id 的 session 来用；</li><li>否则服务器为该客户端创建一个 session 并且生成一个相应的 sessionId，并且在该次响应中返回给客户端保存。</li></ol><p><strong>session的应用</strong><br>session 经常用于保存用户登录状态。比如用户登录成功之后要访问好几个页面，但是每个页面都需要知道是哪个用户在登录，此时就可以将用户的用户名保存在 session 内。</p><p><strong>session的不安全因素</strong><br>session 机制最大的不安全因素是 sessionId 可以被攻击者截获，如果攻击者通过一些手段知道了 sessionId，由于 sessionId 是客户端寻找服务器端 session 对象的唯一标识，攻击者就有可能根据 sesionId 来访问服务器端的 session 对象，得知 session 中的内容，从而实施攻击。</p><p>在 session 机制中，很多人认为：只要浏览器关闭，会话结束，session 就消失了。其实不然，浏览器关闭，会话结束，对于客户端来说，已经无法直接再访问原来的那个 session，但并不代表 session 在服务器端会马上消失。除非程序通知服务器删除一个 session，否则服务器会一直保留这个 session 对象，直到 session 超时失效，被垃圾收集机制收集掉。但是令人遗憾的是，客户在关闭浏览器时，一般不会通知服务器。由于关闭浏览器不会导致 session 被删除，因此，客户端关闭之后，session 还未失效的情况下，就给了攻击者以机会来获取 session 中的内容。</p><p>虽然 sessionId 是随机的长字符串，通常比较难被猜测到，这在某种程度上可以加强其安全性，但是一旦被攻击者获得，就可以进行一些攻击活动，如：攻击者获取客户 sessionId，然后攻击者自行伪造一个相同的 sessionId，访问服务器，实际上等价于伪装成该用户进行操作。</p><p><strong>防止以上因为 sessionId 泄露而造成的安全问题</strong></p><ul><li>在服务器端，可以在客户端登陆系统时，尽量不要使用单一的 sessionId 对用户登陆进行验证。可以通过一定的手段，不时地变更用户的 sessionId；</li><li>在客户端，应该在浏览器关闭时删除服务器端的 session，也就是说在关闭时必须通知服务器端。可以用 Javascript 实现。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;B-S页面间通信&quot;&gt;&lt;a href=&quot;#B-S页面间通信&quot; class=&quot;headerlink&quot; title=&quot;B/S页面间通信&quot;&gt;&lt;/a&gt;B/S页面间通信&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;HTTP是无状态的协议。Web页面本身无法向下一个页面传递信息，如果需要让下一个页
      
    
    </summary>
    
      <category term="Java" scheme="https://jy3321.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://jy3321.github.io/tags/Java/"/>
    
      <category term="JSP" scheme="https://jy3321.github.io/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题：调用try-catch-finally执行过程是怎样的</title>
    <link href="https://jy3321.github.io/2019/09/02/InterviewQuestion-TryCatch/"/>
    <id>https://jy3321.github.io/2019/09/02/InterviewQuestion-TryCatch/</id>
    <published>2019-09-02T10:09:21.000Z</published>
    <updated>2019-09-08T11:22:47.639Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><hr><p>调用下面的方法，得到的返回值是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>.<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="number">3</span>.<span class="keyword">try</span> &#123; </span><br><span class="line"><span class="number">4</span>.<span class="keyword">return</span> a;</span><br><span class="line"><span class="number">5</span>.&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="number">6</span>.System.out.println(<span class="string">"11"</span>);</span><br><span class="line"><span class="number">7</span>.&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="number">8</span>.++a;</span><br><span class="line"><span class="number">9</span>.<span class="keyword">return</span> a; </span><br><span class="line"><span class="number">10</span>.&#125;</span><br><span class="line"><span class="number">11</span>.&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><hr><p>返回 2</p><hr><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><hr><p>代码正常执行try语句块中代码，并没有异常，所以不进入catch块，由于try结果是return语句，所以在返回前执行finally块中的语句，先将a自增，然后执行finally块语句中的return a，所以结果为 2</p><hr><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><hr><p>调用下面的方法，得到的返回值是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">2</span>.<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">3</span>.<span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"><span class="number">4</span>. <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">5</span>.&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="number">6</span>.<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="number">7</span>. &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="number">8</span>.<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="number">9</span>.&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h4><hr><p>返回3</p><hr><h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><hr><p>代码在走到第 3 行的时候遇到了一个 MathException，这时第四行的代码就不会执行了，代码直接跳转到 catch语句中，走到第 6 行的时候，异常机制有这么一个原则：如果在 catch 中遇到了 return 或者异常等能使该函数终止的话，那么有 finally 就必须先执行完 finally 代码块里面的代码然后再返回值。因此代码又跳到第 8 行，可惜第 8 行是一个return 语句，那么这个时候方法就结束了，因此第 6 行的返回结果就无法被真正返回，而是执行了第8行的return 3，因此上面返回值是 3。</p><hr><h3 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h3><hr><p>调用下面的方法，得到的返回值是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">2</span>.<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">3</span>.<span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"><span class="number">4</span>. <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">5</span>.&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="number">6</span>.<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="number">7</span>. &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="number">8</span>.<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="number">9</span>.&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h4><hr><p>返回3</p><hr><h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><hr><p>代码在走到第 3 行的时候遇到了一个 MathException，这时第四行的代码就不会执行了，代码直接跳转到 catch语句中，走到第 6 行的时候，异常机制有这么一个原则：如果在 catch 中遇到了 return 或者异常等能使该函数终止的话，那么有 finally 就必须先执行完 finally 代码块里面的代码然后再返回值。因此代码又跳到第 8 行，可惜第 8 行是一个return 语句，那么这个时候方法就结束了，因此第 6 行的返回结果就无法被真正返回，而是执行了第8行的return 3，因此上面返回值是 3。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;问题1&quot;&gt;&lt;a href=&quot;#问题1&quot; class=&quot;headerlink&quot; title=&quot;问题1&quot;&gt;&lt;/a&gt;问题1&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;调用下面的方法，得到的返回值是什么？&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://jy3321.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://jy3321.github.io/tags/Java/"/>
    
      <category term="面试题" scheme="https://jy3321.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java面试题：对象被当参数传参后属性被改变并返回是传值还是传址</title>
    <link href="https://jy3321.github.io/2019/09/02/InterviewQuestion-byValueOrbyReference/"/>
    <id>https://jy3321.github.io/2019/09/02/InterviewQuestion-byValueOrbyReference/</id>
    <published>2019-09-02T08:23:07.000Z</published>
    <updated>2019-09-02T08:38:06.318Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><hr><p>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</p><hr><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><hr><p>答：是值传递。Java编程语言只有值传递参数。<br>当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用一个副本。指向同一个对象，对象的内容可以在被调用的方法中改变，但对象的引用(不是引用的副本)是永远不会改变的。</p><hr><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><hr><ol><li><p>Java中没有指针，所以也没有引用传递了，仅仅有值传递。不过，可以通过对象的方式来实现引用传递。类似java没有多继承，但可以用多次implements接口实现多继承的功能。</p></li><li><p>在Java应用程序中永远不会传递对象，而只<strong>传递对象的引用</strong>。因此是<strong>按引用传递对象</strong>。但重要的是要区分参数是如何传递的。</p></li><li><p>Java应用程序<strong>按引用传递对象</strong>这一事实并不意味着 Java 应用程序按引用传递参数。参数可以是对象引用，而 Java应用程序是按值传递对象引用的。</p></li><li><p>Java应用程序中的变量可以为以下两种类型之一：引用类型或基本类型。<br>当作为参数传递给一个方法时，处理这两种类型的方式是相同的。<strong>两种类型都是按值传递的</strong>，没有一种按引用传递。</p></li></ol><p><strong>值传递</strong>：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中，对形式参数值的改变不影响实际参数的值。</p><p><strong>引用传递</strong>：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的值。</p><p><strong>按值传递</strong>意味着当将一个参数传递给一个函数时，<strong>函数接收的是原始值的一个副本</strong>。因此，如果函数修改了该参数，仅改变副本，而原始值保持不变。</p><p><strong>按引用传递</strong>意味着当将一个参数传递给一个函数时，<strong>函数接收的是原始值的内存地址</strong>，而不是值的副本。因此，如果函数修改了该参数的值，调用代码中的原始值也随之改变。如果函数修改了该参数的地址，调用代码中的原始值不会改变。</p><hr><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数中传递的是基本数据类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">3</span>;  </span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">4</span>;  </span><br><span class="line">        change(a, b);  </span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a); <span class="comment">// 3</span></span><br><span class="line">        System.out.println(<span class="string">"b="</span> + b); <span class="comment">// 4  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> temp = i;  </span><br><span class="line">        i = j;  </span><br><span class="line">        j = temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为:<br>a=3<br>b=4  </p><p>原因：参数中传递的是基本数据类型a和b的拷贝，在函数中交换的也是那份拷贝的值，而不是数据本身。</p><hr><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数中传的是引用数据类型  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span>[] count = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;  </span><br><span class="line">        change(count);  <span class="comment">// 6</span></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] counts)</span> </span>&#123;  </span><br><span class="line">        counts[<span class="number">0</span>] = <span class="number">6</span>;  </span><br><span class="line">        System.out.println(counts[<span class="number">0</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br>6</p><p>原因：在方法中，传递引用数据类型int数组，实际上传递的是该数组的地址值，他们都指向数组对象，在方法中可以改变数组对象的内容。</p><hr><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">传递的是对象的引用  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </span><br><span class="line">        A a = <span class="keyword">new</span> A();  </span><br><span class="line">        add(a); <span class="comment">// 1  </span></span><br><span class="line">        System.out.println(a.i);  <span class="comment">// 0</span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(A a)</span> </span>&#123;  </span><br><span class="line">        a = <span class="keyword">new</span> A();  </span><br><span class="line">        a.i++;</span><br><span class="line">        System.out.println(a.i); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br>1<br>0  </p><p>原因：在该程序中，对象的引用指向的是A，而在add方法中，传递的引用的一份副本则指向了一个新的对象，并对新的对象进行操作。而原来的A对象并没有发生任何变化。引用指向的是还是原来的A对象。 </p><hr><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 不改变，数组改变</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </span><br><span class="line">        Example ex = <span class="keyword">new</span> Example();  </span><br><span class="line">        ex.change(ex.str, ex.ch);  </span><br><span class="line">        System.out.print(ex.str + <span class="string">" and "</span>); <span class="comment">// good and</span></span><br><span class="line">        System.out.println(ex.ch); <span class="comment">// gbc</span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"good"</span>); <span class="comment">// good 是常量，不能改</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span> </span>&#123;  </span><br><span class="line">        str = <span class="string">"test ok"</span>; <span class="comment">// test ok 又是一个常量，也不能改 　　等价于 String str1 = new String("test ok");</span></span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">'g'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br>good and gbc </p><p>原因：String类比较特别，看过String类代码的都知道，String类是final修饰的。所以值是不变的。<br>函数中String对象引用的副本指向了另外一个新String对象，而数组对象引用的副本没有改变，而是改变对象中数据的内容。<br>对于对象类型，也就是Object的子类，如果你在方法中修改了它的成员的值，那个修改是生效的，方法调用结束后，它的成员是新的值；但是如果你把它指向一个其它的对象，方法调用结束后，原来对它的引用并没用指向新的对象。</p><hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://jy3321.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://jy3321.github.io/tags/Java/"/>
    
      <category term="面试题" scheme="https://jy3321.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法题目整理（持续添加更新）</title>
    <link href="https://jy3321.github.io/2019/09/01/AlgorithmicProblems/"/>
    <id>https://jy3321.github.io/2019/09/01/AlgorithmicProblems/</id>
    <published>2019-09-01T06:43:24.000Z</published>
    <updated>2019-09-20T12:52:20.134Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文会将遇到的比较经典的算法题进行汇总，便于自己回忆学习，其中大部分题目和题解来自于 <a href="https://leetcode-cn.com/" target="_blank" rel="noopener">LeetCode</a>（侵删）,会持续更新扩充。</p><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h3><hr><p><strong>题目</strong><br>给定一个字符串 s，找到 s 中最长的回文子串。</p><p><strong>解答</strong><br>回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n - 1个这样的中心。</p><p>你可能会问，为什么会是 2n - 1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如“abba” 的中心在两个‘b’ 之间）。所以中心点既有可能是一个字符，也有可能是两个字符，当中心为一个字符的时候有n个中心，当中心为两个字符的时候有n-1个中心，所以一共有2n-1个中心。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n^2)<br>由于围绕中心来扩展回文会耗去 O(n)O(n) 的时间，所以总的复杂度为 O(n^2)</li><li>空间复杂度：O(1)。</li></ul><p><strong>其它更优方法</strong></p><ul><li>Manacher 算法<br>还有一个复杂度为 O(n)O(n) 的 Manacher 算法，可以参考<br><a href="https://www.jianshu.com/p/116aa58b7d81" target="_blank" rel="noopener">https://www.jianshu.com/p/116aa58b7d81</a></li></ul><p>简单讲就是可以在字符串的每个字符前后各加一个不影响判断回文的字符，例如‘#‘,”aca“和”acca“，中心分别为’c‘和“cc“的中间，增添后的“#a#c#a#”，“#a#c#c#a#”，都为奇数长度的字符串，也就不会出现中心点在两个字符中间的情况。然后计算并通过回文半径进行判断。</p><hr><h3 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572.另一个树的子树"></a>572.另一个树的子树</h3><hr><p><strong>题目</strong><br>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><p><strong>解答</strong><br>解决此题的思路非常简单，其实就是去比较s树每一个节点对应的子树是否和t相同，如果至少有一棵相同就返回true。</p><p>因此说白了就两步：</p><p>遍历s树。<br>根据遍历结果，判断俩树是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历s树，去比较s树的每一个节点作为根节点对应的子树是否和t相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> isSame(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断s和t两棵树是否相等</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.val == t.val &amp;&amp; isSame(s.left, t.left) &amp;&amp; isSame(s.right, t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>在学习这道题的时候，理解了如何去做一道递归题目，在刚开始解决递归问题的时候，总是会去纠结这一层函数做了什么，它调用自身后的下一层函数又做了什么…然后就会觉得实现一个递归解法十分复杂，根本就无从下手。</p><p>相信很多刚开始做递归题的人都和我一样，这是一个思维误区，一定要走出来。既然递归是一个反复调用自身的过程，这就说明它每一级的功能都是一样的，<strong>因此我们只需要关注一级递归的解决过程即可</strong>。</p><p><strong>递归时，我们应该这样想：</strong><br><strong>递归应该在什么时候结束？（找整个递归的终止条件）</strong><br><strong>应该给上一级返回什么信息？（找返回值）</strong><br><strong>在一级递归中，应该完成什么任务？（本级递归应该做什么）</strong></p><hr><h3 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a>数组的相对排序</h3><hr><p><strong>题目</strong><br>给你两个数组，arr1 和 arr2，</p><ul><li>arr2 中的元素各不相同</li><li>arr2 中的每个元素都出现在 arr1 中<br>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</li></ul><p><strong>示例</strong><br>    输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]<br>    输出：[2,2,2,1,4,3,3,9,6,7,19]</p><p><strong>提示</strong></p><ul><li>arr1.length, arr2.length &lt;= 1000</li><li>0 &lt;= arr1[i], arr2[i] &lt;= 1000</li><li>arr2 中的元素 arr2[i] 各不相同</li><li>arr2 中的每个元素 arr2[i] 都出现在 arr1 中</li></ul><hr><h3 id="字节跳动笔试题：万万没想到之聪明的编辑"><a href="#字节跳动笔试题：万万没想到之聪明的编辑" class="headerlink" title="字节跳动笔试题：万万没想到之聪明的编辑"></a>字节跳动笔试题：万万没想到之聪明的编辑</h3><hr><p><strong>题目：</strong><br>我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径：</p><ol><li>三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -&gt; hello</li><li>两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -&gt; hello</li><li>上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC</li></ol><p>我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！<br>……<br>万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的……</p><p>请听题：请实现大锤的自动校对程序</p><p><strong>方法一：正常思路实现功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">        String[] strings = <span class="keyword">new</span> String[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            strings[i] = sc.next();</span><br><span class="line">        &#125;</span><br><span class="line">        Solution1 solution = <span class="keyword">new</span> Solution1();</span><br><span class="line">        <span class="keyword">for</span> (String str : strings)</span><br><span class="line">            System.out.println(solution.solve(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt;= <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(i + <span class="number">1</span>) &amp;&amp; s.charAt(i + <span class="number">2</span>) == s.charAt(i + <span class="number">3</span>)) &#123;<span class="comment">//AABB</span></span><br><span class="line">                s = delete(s, i + <span class="number">2</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == s.charAt(i + <span class="number">1</span>) &amp;&amp; s.charAt(i) == s.charAt(i + <span class="number">2</span>))&#123;<span class="comment">//AAA</span></span><br><span class="line">                s = delete(s,i);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(n - <span class="number">1</span>) == s.charAt(n - <span class="number">2</span>) &amp;&amp; s.charAt(n - <span class="number">1</span>) == s.charAt(n - <span class="number">3</span>))<span class="comment">//可能结尾剩余3个AAA的情况</span></span><br><span class="line">            s = delete(s,n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">delete</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(<span class="number">0</span>, i) + s.substring(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：巧用转义字符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> line = scanner.nextInt();</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line; i++) &#123;</span><br><span class="line">            System.out.println(scanner.nextLine().replaceAll(<span class="string">"(.)\\1+"</span>,<span class="string">"$1$1"</span>).replaceAll(<span class="string">"(.)\\1(.)\\2"</span>,<span class="string">"$1$1$2"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id><a href="#" class="headerlink" title="### "></a>### </h2><hr><h2 id="-1"><a href="#-1" class="headerlink" title="### "></a>### </h2><hr><h2 id="-2"><a href="#-2" class="headerlink" title="### "></a>### </h2><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文会将遇到的比较经典的算法题进行汇总，便于自己回忆学习，其中大部分题目和题解来自于 &lt;a href=&quot;https://leetc
      
    
    </summary>
    
      <category term="算法" scheme="https://jy3321.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://jy3321.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础问题</title>
    <link href="https://jy3321.github.io/2019/08/29/ComputerNetwork/"/>
    <id>https://jy3321.github.io/2019/08/29/ComputerNetwork/</id>
    <published>2019-08-29T08:22:25.000Z</published>
    <updated>2019-08-29T09:24:51.620Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="OSI与TCP-IP各层的结构与功能"><a href="#OSI与TCP-IP各层的结构与功能" class="headerlink" title="OSI与TCP/IP各层的结构与功能"></a>OSI与TCP/IP各层的结构与功能</h3><hr><p><strong>五层协议的体系结构</strong><br>学习计算机网络时我们一般中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/2999225966-5b5f220d89e9c_articlex.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>综合互联网情况，自上而下简要介绍一下各层的作用</p><h4 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h4><p><code>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用</code>。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<code>域名系统DNS</code>，支持万维网应用的 <code>HTTP协议</code>，支持电子邮件的 <code>SMTP协议</code>等等。我们把应用层交互的数据单元称为报文。</p><p><strong>域名系统</strong><br>    域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联    网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com" target="_blank" rel="noopener">www.ibm.com</a> 、 Oracle 公司的域名是 <a href="http://www.oracle.com" target="_blank" rel="noopener">www.oracle.com</a> 等。</p><p><strong>HTTP协议</strong><br>    超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p><h4 id="2-运输层"><a href="#2-运输层" class="headerlink" title="2. 运输层"></a>2. 运输层</h4><p><code>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</code>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p><p><strong>运输层主要使用以下两种协议</strong></p><ul><li>传输控制协议 TCP（Transmisson Control Protocol）–提供面向连接的，可靠的数据传输服务。</li><li>用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li></ul><p><strong>UDP 的主要特点</strong></p><ul><li>UDP 是无连接的；</li><li>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li><li>UDP 是面向报文的；</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信；</li><li>UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li></ul><p><strong>TCP 的主要特点</strong></p><ul><li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li><li>每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li><li>TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li><li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li><li>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li></ul><h4 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h4><p><code>网络层(network layer)负责为分组交换网上的不同主机提供通信服务</code>。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用<code>IP 协议</code>，因此分组也叫<code>IP 数据报</code> ，简称 <code>数据报</code>。</p><p><code>这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</code>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分株，能通过网络层中的路由器找到目的主机。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。</p><h4 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4. 数据链路层"></a>4. 数据链路层</h4><p><code>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议</code>。 在两个相邻节点之间传送数据时，<code>数据链路层将网络层交下来的 IP 数据报组装程帧</code>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。<br>控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p><h4 id="5-物理层"><a href="#5-物理层" class="headerlink" title="5. 物理层"></a>5. 物理层</h4><p><code>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</code>。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>在物理层上所传送的数据单位是比特。</p><p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p><h4 id="体系结构图"><a href="#体系结构图" class="headerlink" title="体系结构图"></a>体系结构图</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/3864529920-56fde9b5acc5a_articlex.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p>图片来源及OSI相关知识点参考博客 ：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">https://blog.csdn.net/yaopeng_2005/article/details/7064869</a></p><hr><h3 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h3><hr><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。<br><strong>三次握手：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/2016135021-5af6d4854ee92_articlex.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>图片来源：《图解HTTP》</p><p><img src="/2019/08/29/ComputerNetwork/4238626793-5af6d484ce1e4_articlex.jpg" alt></p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><p><strong>四次挥手</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/2408896382-5af6d484a6ee5_articlex.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>断开一个 TCP 连接则需要“四次挥手”</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li></ul><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p><code>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</code></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><p>推荐参考一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p><h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><h4 id="传了-SYN-为什么还要传-ACK"><a href="#传了-SYN-为什么还要传-ACK" class="headerlink" title="传了 SYN,为什么还要传 ACK"></a>传了 SYN,为什么还要传 ACK</h4><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p><hr><h3 id="TCP、UDP-协议的区别"><a href="#TCP、UDP-协议的区别" class="headerlink" title="TCP、UDP 协议的区别"></a>TCP、UDP 协议的区别</h3><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/QQ图片20190829165439.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><hr><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><hr><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li>拥塞控制： 当网络拥塞时，减少数据的发送。</li><li>停止等待协议 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；<br>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</p><h5 id="1-无差错情况"><a href="#1-无差错情况" class="headerlink" title="1) 无差错情况:"></a>1) 无差错情况:</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/1018119648-5b76606d2b500_articlex.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><h5 id="2-出现差错情况（超时重传）"><a href="#2-出现差错情况（超时重传）" class="headerlink" title="2) 出现差错情况（超时重传）:"></a>2) 出现差错情况（超时重传）:</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/3364275969-5b76606cca5ec_articlex.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><h5 id="3-确认丢失和确认迟到"><a href="#3-确认丢失和确认迟到" class="headerlink" title="3) 确认丢失和确认迟到"></a>3) 确认丢失和确认迟到</h5><ul><li><p>确认丢失：确认消息在传输过程丢失</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/3260481698-5b76606ce1b7b_articlex.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：</p><ol><li>丢弃这个重复的M1消息，不向上层交付。</li><li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li></ol></li><li><p>确认迟到 ：确认消息在传输过程中迟到</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/2459607350-5b76606cc9d8d_articlex.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：</p><pre><code>1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</code></pre><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p><p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><ul><li><p>TCP 利用滑动窗口实现流量控制的机制。</p></li><li><p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p></li><li><p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p></li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul><li><p>TCP 利用滑动窗口实现流量控制。</p></li><li><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p></li><li><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p></li></ul><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <code>拥塞窗口(cwnd)</code>的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 <code>慢开始 、 拥塞避免 、快重传</code> 和 <code>快恢复</code>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li>慢开始  慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/1982688216-5b76606ccf0d3_articlex.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li><li>快重传与快恢复：在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/2206504379-5b76606d144fa_articlex.png" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><h3 id="在浏览器中输入url地址-gt-gt-显示主页的过程"><a href="#在浏览器中输入url地址-gt-gt-显示主页的过程" class="headerlink" title="在浏览器中输入url地址 -&gt;&gt; 显示主页的过程"></a>在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</h3><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/QQ图片20190829171306.png" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/40813439-5af6d48505a49_articlex.png" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><h3 id="各种协议与HTTP协议之间的关系"><a href="#各种协议与HTTP协议之间的关系" class="headerlink" title="各种协议与HTTP协议之间的关系"></a>各种协议与HTTP协议之间的关系</h3><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/29/ComputerNetwork/1376447618-5af6d4856d87a_articlex.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>图片来源：《图解HTTP》</p><hr><h3 id="HTTP长连接、短连接"><a href="#HTTP长连接、短连接" class="headerlink" title="HTTP长连接、短连接"></a>HTTP长连接、短连接</h3><hr><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong><br>参考文章：<a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">https://www.cnblogs.com/gotodsp/p/6366163.html</a></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>问题：</p><ul><li>TCP三次握手和四次挥手、</li><li>在浏览器中输入url地址-&gt;&gt;显示主页的过程</li><li>HTTP和HTTPS的区别</li><li>TCP、UDP协议的区别</li><li>常见的状态码。</li></ul><p>参考了大量网上的资料及回答，部分引用内容下有参考博客的连接，文中大部分的图片来自于《图解HTTP》 。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;OSI与TCP-IP各层的结构与功能&quot;&gt;&lt;a href=&quot;#OSI与TCP-IP各层的结构与功能&quot; class=&quot;headerlink&quot; title=&quot;OSI与TCP/IP各层的结构与功能&quot;&gt;&lt;/a&gt;OSI与TCP/IP各层的结构与功能&lt;/h3&gt;&lt;hr&gt;
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://jy3321.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://jy3321.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java中@Override的作用</title>
    <link href="https://jy3321.github.io/2019/08/23/Override/"/>
    <id>https://jy3321.github.io/2019/08/23/Override/</id>
    <published>2019-08-23T06:01:21.000Z</published>
    <updated>2019-08-23T06:31:13.418Z</updated>
    
    <content type="html"><![CDATA[<p><strong>@Override</strong>是伪代码,表示重写，在java代码编写时经常会看到，写上它有如下好处: </p><ol><li><p>可以当注释用,方便阅读；</p></li><li><p>编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。<br>如果你在继承父类没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。</p></li></ol><p>举例：在重写父类的onCreate时，在方法前面加上@Override 系统可以帮你检查方法的正确性。</p><pre><code>@Overridepublic void onCreate(Bundle savedInstanceState){……}</code></pre><p>这种写法是正确的，如果你写成：</p><pre><code>@Overridepublic void oncreate(Bundle savedInstanceState){……}</code></pre><p>编译器会报如下错误：The method oncreate(Bundle) of type HelloWorld must override or implement a supertype method，以确保你正确重写onCreate方法（因为oncreate应该为onCreate）。而如果你不加@Override，则编译器将不会检测出错误，而是会认为你为子类定义了一个叫oncreate的新方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;@Override&lt;/strong&gt;是伪代码,表示重写，在java代码编写时经常会看到，写上它有如下好处: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以当注释用,方便阅读；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译器可以给你验证@Override下面的方法名是否是你
      
    
    </summary>
    
      <category term="Java" scheme="https://jy3321.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://jy3321.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程问题合集</title>
    <link href="https://jy3321.github.io/2019/08/22/Multithreading/"/>
    <id>https://jy3321.github.io/2019/08/22/Multithreading/</id>
    <published>2019-08-22T12:52:53.000Z</published>
    <updated>2019-08-23T06:29:51.663Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>参考了网上关于多线程的题目，将题目汇总如下，便于自己记忆</code></p><p><strong>1、多线程有什么用？</strong></p><p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p><p>（1）发挥多核CPU的优势</p><p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。<strong>单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了</strong>。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p><p>（2）防止阻塞</p><p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><p>（3）便于建模</p><p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><p><strong>2、创建线程的方式</strong></p><p>比较常见的一个问题了，一般就是两种：</p><p>（1）继承Thread类</p><p>（2）实现Runnable接口</p><p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，<strong>面向接口编程</strong>也是设计模式6大原则的核心。</p><p><strong>3、start()方法和run()方法的区别</strong></p><p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p><p><strong>4、Runnable接口和Callable接口的区别</strong></p><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>这其实是很有用的一个特性，因为<strong>多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p><p><strong>5、CyclicBarrier和CountDownLatch的区别</strong></p><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p><p><strong>6、volatile关键字的作用</strong></p><p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：</p><p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p><p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是<strong>Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互</strong>，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p><p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p><p><strong>7、什么是线程安全</strong></p><p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：<strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的</strong>。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><p>（1）不可变</p><p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><p>（2）绝对线程安全</p><p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><p>（3）相对线程安全</p><p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是<strong>fail-fast机制</strong>。</p><p>（4）线程非安全</p><p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><p><strong>8、Java中如何获取到线程dump文件</strong></p><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p><p><strong>9、一个线程如果出现了运行时异常会怎么样</strong></p><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：<strong>如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</strong></p><p><strong>10、如何在两个线程之间共享数据</strong></p><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><p><strong>11、sleep方法和wait方法有什么区别</strong> </p><p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><p><strong>12、生产者消费者模型的作用是什么</strong></p><p>这个问题很理论，但是很重要：</p><p>（1）<strong>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率</strong>，这是生产者消费者模型最重要的作用</p><p>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p><p><strong>13、ThreadLocal有什么用</strong></p><p>简单说ThreadLocal就是一种以<strong>空间换时间</strong>的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p><p><strong>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</strong></p><p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p><p><strong>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</strong></p><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：<strong>wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器</strong>。</p><p><strong>16、为什么要使用线程池</strong></p><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><p><strong>17、怎么检测一个线程是否持有对象监视器</strong></p><p>我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着<strong>“某条线程”指的是当前线程</strong>。</p><p><strong>18、synchronized和ReentrantLock的区别</strong></p><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><p><strong>19、ConcurrentHashMap的并发度是什么</strong></p><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><p><strong>20、ReadWriteLock是什么</strong></p><p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，<strong>读锁是共享的，写锁是独占的</strong>，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><p><strong>21、FutureTask是什么</strong></p><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><p><strong>22、Linux环境下如何查找哪个线程使用CPU最长</strong></p><p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p><p>（2）top -H -p pid，顺序不能改变</p><p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><p><strong>23、Java编程写一个会导致死锁的程序</strong></p><p>第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p><p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p><p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p><p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p><p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p><p>这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。</p><p><strong>24、怎么唤醒一个阻塞的线程</strong></p><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><p><strong>25、不可变对象对多线程有什么帮助</strong></p><p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><p><strong>26、什么是多线程的上下文切换</strong></p><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><p><strong>27、如果你提交任务时，线程池队列已满，这时会发生什么</strong></p><p>这里区分一下：</p><ol><li>如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务</li><li>如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</li></ol><p><strong>28、Java中用到的线程调度算法是什么</strong></p><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><p><strong>29、Thread.sleep(0)的作用是什么</strong></p><p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><p><strong>30、什么是自旋</strong></p><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><p><strong>31、什么是Java内存模型</strong></p><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p><p>（1）Java内存模型将内存分为了<strong>主内存和工作内存</strong>。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p><p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p><p>（3）定义了volatile变量的使用规则</p><p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p><p><strong>32、什么是CAS</strong></p><p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：<strong>内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false</strong>。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p><p><strong>33、什么是乐观锁和悲观锁</strong></p><p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将<strong>比较-替换</strong>这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><p><strong>34、什么是AQS</strong></p><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p><p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p><p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><p><strong>35、单例模式的线程安全性</strong></p><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：<strong>某个类的实例在多线程环境下只会被创建一次出来</strong>。单例模式有很多种的写法，我总结一下：</p><p>（1）饿汉式单例模式的写法：线程安全</p><p>（2）懒汉式单例模式的写法：非线程安全</p><p>（3）双检锁单例模式的写法：线程安全</p><p><strong>36、Semaphore有什么作用</strong></p><p>Semaphore就是一个信号量，它的作用是<strong>限制某段代码块的并发数</strong>。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p><p><strong>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</strong></p><p>这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p><p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p><p>（1）<strong>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问</strong>。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p><p>（2）<strong>CPU执行代码，执行的不是Java代码，这点很关键，一定得记住</strong>。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。<strong>即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个</strong>。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。</p><p><strong>38、线程类的构造方法、静态块是被哪个线程调用的</strong></p><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p><p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p><p><strong>39、同步方法和同步块，哪个是更好的选择</strong></p><p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：<strong>同步的范围越小越好</strong>。</p><p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做<strong>锁粗化</strong>的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><p><strong>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</strong></p><p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p><p>（2）并发不高、任务执行时间长的业务要区分开看：</p><p>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p><p>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p><p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;code&gt;参考了网上关于多线程的题目，将题目汇总如下，便于自己记忆&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、多线程有什么用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯
      
    
    </summary>
    
      <category term="Java" scheme="https://jy3321.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://jy3321.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://jy3321.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存机制及堆和栈的区别</title>
    <link href="https://jy3321.github.io/2019/08/18/StackAndHeap/"/>
    <id>https://jy3321.github.io/2019/08/18/StackAndHeap/</id>
    <published>2019-08-18T08:42:22.000Z</published>
    <updated>2019-08-22T04:02:36.317Z</updated>
    
    <content type="html"><![CDATA[<hr><p>​    </p><h3 id="几个计算机基础概念"><a href="#几个计算机基础概念" class="headerlink" title="几个计算机基础概念"></a>几个计算机基础概念</h3><hr><ol><li>计算机存储单位</li></ol><p>从小到大依次为<code>位Bit</code>、<code>字节Byte</code>、<code>千字节KB</code>、<code>兆M</code>、<code>千兆GB</code>、<code>TB</code>，相邻单位之间都是1024倍，1024为2的10次方，即：</p><ul><li><p>1Byte = 8bit</p></li><li><p>1K = 1024Byte</p></li><li><p>1M = 1024K</p></li><li><p>1G = 1024M</p></li><li><p>1T = 1024G</p></li></ul><ol start="2"><li>计算机存储元件</li></ol><p>寄存器：中央处理器CPU的一部分，是计算机中读写速度最快的存储元件，但是容量很少</p><p>内存：属于独立的一个部件，是和CPU沟通的桥梁，用于存放CPU中的运算数据以及与外部存储器交换的数据。尽管在今天，对内存的读写速度已经很快了，但是由于寄存器是在CPU上的，所以对于内存的读写速度和对于寄存器的读写速度上还是有几个数量级的差距。但是没办法，对于内存的读写I/O操作是很难消除的，寄存器数量有限，不可能通过寄存器来完成所有的运算任务</p><ol start="3"><li>内核空间和用户空间</li></ol><p>连接内存和寄存器的是地址总线，地址总线的宽度影响了物理地址的索引范围，因为总线宽度决定了处理器一次可以从寄存器或内存中获取多少个Bit，同时也决定了处理器最大可以寻址的地址空间。比如32位CPU的系统，可寻址范围为0x00000000~0xFFFFFFFF，即232=4294967296个内存位置，每个内存位置1个字节，即32位CPU系统可以有4GB的内存空间。不过应用程序是不可以完全使用这些地址空间的，因为这些地址空间被划分为了内核空间和用户空间，程序只能使用用户空间的内存。内核空间主要是指操作系统运行时所使用的用于程序调度、虚拟内存的使用或者链接硬件资源的程序逻辑。区分内核空间和用户空间的目的主要是从系统的稳定性的角度考虑的。Windows 32操作系统默认内核空间和用户空间的比例是1:1，即2G内核空间、2G内存空间，32位Linux系统中默认比例则是1:3，即1G内核空间，3G内存空间。</p><ol start="4"><li>字长</li></ol><p>CPU的主要技术指标之一，指的是CPU一次能并行处理二进制的位数（Bit）。通常称处理字长为8位数据的CPU为8位CPU，32位CPU就是在同一时间内处理字长为32位的二进制数据。不过目前虽然CPU大多是64位的，但还是以32位字长运行。</p><hr><h3 id="Java内存机制"><a href="#Java内存机制" class="headerlink" title="Java内存机制"></a>Java内存机制</h3><hr><h4 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h4><p>Java虚拟机（JVM）内部定义了程序在运行时需要使用到的内存区域。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/18/StackAndHeap/1546597-20190528150139570-1775084794.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>之所以要划分这么多区域出来是因为这些区域都有自己的用途，以及创建和销毁的时间。</p><p>有些区域随着虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而销毁和建立。</p><p>图中绿色部分就是所有线程之间共享的内存区域，而白色部分则是线程运行时独有的数据区域，从这个分类角度来看一下这几个数据区。</p><h5 id="线程独有的内存区域"><a href="#线程独有的内存区域" class="headerlink" title="线程独有的内存区域"></a>线程独有的内存区域</h5><h5 id="PROGRAM-COUNTER-REGISTER，程序计数器"><a href="#PROGRAM-COUNTER-REGISTER，程序计数器" class="headerlink" title="PROGRAM COUNTER REGISTER，程序计数器"></a><strong>PROGRAM COUNTER REGISTER，程序计数器</strong></h5><p>程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是<code>通过改变这个计数器的值来选取下一条需要执行的字节码指令</code>，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，<code>每条线程都需要有一个独立的程序计数器</code>，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是<code>正在执行的虚拟机字节码指令的地址</code>；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p><p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><p><strong>JAVA STACK，虚拟机栈</strong></p><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是Java方法执行的内存模型，<code>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息</code>。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而<code>所指的“栈”就是现在讲的虚拟机栈</code>，或者说是<code>虚拟机栈中的局部变量表部分</code>。</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。</p><p>局部变量表所需的内存空间在<code>编译期间</code>完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出<code>OutOfMemoryError</code>异常。</p><p><strong>NATIVE METHOD STACK，本地方法栈</strong><br>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈<code>为虚拟机执行Java方法（也就是字节码）服务</code>，而本地方法栈则是<code>为虚拟机使用到的Native方法服务</code>。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</p><p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError异常和OutOfMemoryError异常。</p><h5 id="线程间共享的内存区域"><a href="#线程间共享的内存区域" class="headerlink" title="线程间共享的内存区域"></a>线程间共享的内存区域</h5><p><strong>HEAP，堆</strong></p><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。</p><p>Java堆是<code>被所有线程共享</code>的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：<code>所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了</code>。</p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。</p><p>如果从内存回收的角度看，由于现在收集器基本都是采用的<code>分代收集算法</code>，所以Java堆中还可以细分为：<code>新生代</code>和<code>老年代</code>；再细致一点的有<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>等。</p><p>如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p><p>不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><p><strong>METHOD AREA，方法区</strong></p><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储<code>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</code>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。</p><p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标<code>主要是针对常量池的回收和对类型的卸载</code>，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><p><strong>RUNTIME CONSTANT POOL，运行时常量池</strong></p><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有<code>类的版本、字段、方法、接口</code>等描述信息外，还有一项信息是<code>常量池（Constant Pool Table）</code>，用于<code>存放编译期生成的各种字面量和符号引用</code>，这部分内容将在类加载后存放到方法区的<code>运行时常量池</code>中。</p><p>Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是<code>具备动态性</code>，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是<code>String类的intern()方法</code>。</p><p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常。</p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>Java是一门面向对象的语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象（克隆、反序列化）就是一个new关键字而已，但是虚拟机层面上却不是如此。看一下在虚拟机层面上创建对象的步骤：</p><ol><li><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有，那么必须先执行类的初始化过程。</p></li><li><p>类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存大小在类加载完成后便可以完全确定，为对象分配空间无非就是从Java堆中划分出一块确定大小的内存而已。这个地方会有两个问题：</p></li></ol><p>（1）如果内存是规整的，那么虚拟机将采用的是指针碰撞法来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。</p><p>（2）如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。</p><p>另外一个问题及时保证new对象时候的线程安全性。因为可能出现虚拟机正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。虚拟机采用了CAS（Compare-and-Swap，即比较并替换，是一种实现并发算法时常用到的技术）配上失败重试的方式保证更新更新操作的原子性和TLAB（Thread Local Allocation Buffer，划分出多个线程私有的分配缓冲区）两种方式来解决这个问题。</p><ol start="3"><li><p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></li><li><p>对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。</p></li><li><p>执行 <code>init</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p></li></ol><h4 id="访问对象"><a href="#访问对象" class="headerlink" title="访问对象"></a>访问对象</h4><p>对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及<code>Java栈</code>、<code>ava堆</code>、<code>方法区</code>这三个最重要内存区域之间的关联关系，如下面的这句代码：</p><p><code>1 Object obj = new Object();</code></p><p>假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到<code>Java栈的本地变量表</code>中，作为一个<code>reference类型数据</code>出现。而“new Object()”这部分的语义将会反映到<code>Java堆</code>中，形成一块<code>存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）</code>的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象<code>类型数据（如对象类型、父类、实现的接口、方法等）的地址信息</code>，这些类型数据则存储在方法区中。</p><p>由于reference类型在Java虚拟机规范里面只规定了一个<code>指向对象的引用</code>，并没有定义这个引用<code>应该通过哪种方式去定位</code>，以及<code>访问到Java堆中的对象的具体位置</code>，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：<code>使用句柄</code>和<code>直接指针</code>。</p><p>如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p><p>如果使用的是直接指针访问方式，Java堆对象的布局中就必须考虑<code>如何放置访问类型数据的相关信息</code>，reference中直接存储的就是<code>对象地址</code>。</p><p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是<code>速度更快</code>，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p><hr><h3 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h3><hr><p><strong>问题一：</strong></p><pre><code>String str1 = &quot;abc&quot;;String str2 = &quot;abc&quot;;System.out.println(str1==str2); //true</code></pre><p><strong>问题二：</strong></p><pre><code>String str1 =new String (&quot;abc&quot;);String str2 =new String (&quot;abc&quot;);System.out.println(str1==str2); // false</code></pre><p><strong>问题三:</strong></p><pre><code>String s1 = &quot;ja&quot;;String s2 = &quot;va&quot;;String s3 = &quot;java&quot;;String s4 = s1 + s2;System.out.println(s3 == s4);//falseSystem.out.println(s3.equals(s4));//true</code></pre><p>在函数中定义的一些基本类型的变量和对象的引用变量都在函数的<code>栈</code>内存中分配。<br>当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p><p><code>堆内存用来存放由new创建的对象和数组。</code></p><p>在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。<br>在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。</p><h4 id="具体的说"><a href="#具体的说" class="headerlink" title="具体的说"></a>具体的说</h4><p>栈与堆都是Java用来在Ram中存放数据的地方。<code>与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</code></p><p>Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过<code>new</code> 、<code>newarray</code> 、<code>anewarray</code> 和<code>multianewarray</code> 等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，<code>因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</code> </p><p>栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。</p><p>栈有一个很重要的特殊性，就是存在栈中的数据可以<code>共享</code>。假设我们同时定义：<br>    int a = 3;<br>    int b = 3；</p><p>编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。</p><p>String是一个特殊的包装类数据。可以用：<br>    String str = new String(“abc”);<br>    String str = “abc”;</p><p>两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。</p><p>而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放”abc”，如果没有，则将”abc”存放进栈，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。<br><code>比较类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==</code></p><p>下面用例子说明上面的理论。</p><p><strong>方式一：</strong></p><pre><code>String str1 = &quot;abc&quot;;String str2 = &quot;abc&quot;;System.out.println(str1==str2); //true</code></pre><p>可以看出str1和str2是指向同一个对象的。</p><p><strong>方式二：</strong></p><pre><code>String str1 =new String (&quot;abc&quot;);String str2 =new String (&quot;abc&quot;);System.out.println(str1==str2); // false</code></pre><p>用new的方式是生成不同的对象。每一次生成一个。</p><p>因此用第一种方式创建多个”abc”字符串,在内存中其实只存在一个对象而已. 这种写法有利与节省内存空间. 同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(“abc”)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。</p><p>另一方面, 要注意: 我们在使用诸如String str = “abc”；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！<code>对象可能并没有被创建！而可能只是指向一个先前已经创建的对象。</code>只有通过new()方法才能保证每次都创建一个新的对象。由于String类的immutable性质，<code>当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率</code>。</p><hr><h3 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h3><hr><p>　堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，队列优先,先进先出（FIFO—first in first out）。栈，先进后出(FILO—First-In/Last-Out)。</p><hr><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><hr><p><strong>一、空间分配</strong></p><p>1.堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表。PS：java中都是系统GC，程序员无法进行GC。<br>2.栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量值等。操作方式与数据结构中的栈相类似。    </p><p><strong>二、缓存方式</strong>   </p><p>1.堆：使用二级缓存，生命周期与虚拟机的GC算法有关（并不是引用为空就立即被GC），调用速度相对较低。<br>2.栈：使用一级缓存，被调用时通常处于存储空间中，调用后被立即释放。    </p><p><strong>三、数据结构</strong></p><p>1、堆（数据结构）：类似于树结构，可以类比于堆排序<br>2、栈（数据结构）：先进后出（FILO）   </p><p><strong>JAVA中的区别</strong> </p><p> 堆（heap）与栈（stack）都是java在RAM中用来存放数据的地方。<code>与C++不同的是，java自动管理堆（heap）和（栈），程序员不能直接的设置堆和栈。</code>  </p><p>栈：在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被用作他用。</p><p>堆：对内存用来存放由new创建的对象和数组，在堆中分配的内存，由java虚拟机的自动垃圾回收器来管理。在堆中产生一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。    </p><hr><h3 id="Java中变量在内存中的分配"><a href="#Java中变量在内存中的分配" class="headerlink" title="Java中变量在内存中的分配"></a>Java中变量在内存中的分配</h3><hr><p>1.类变量（static修饰的变量，静态变量）：在程序加载时系统就为他在队中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期——一直到系统关闭。   </p><p>2.实例变量（实例化对象）：当你使用java关键字new时，系统在堆中开辟并不一定是连续的空间分配给变量，然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的“物理位置”。实例变量的生命周期——实例变量的引用丢失后，将被GC列入到可回收名单中，但不是马上回收释放。    </p><p>3.局部变量：生命在某个方法或者某段代码里面，执行到他的时候在栈中开辟内存，局部变量一旦脱离作用域，内存立即释放。</p><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>部分内容参考以下博客：</p><p><a href="https://www.cnblogs.com/xrq730/p/4827590.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/4827590.html</a></p><p><a href="https://www.cnblogs.com/gw811/p/2730117.html" target="_blank" rel="noopener">https://www.cnblogs.com/gw811/p/2730117.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;​    &lt;/p&gt;
&lt;h3 id=&quot;几个计算机基础概念&quot;&gt;&lt;a href=&quot;#几个计算机基础概念&quot; class=&quot;headerlink&quot; title=&quot;几个计算机基础概念&quot;&gt;&lt;/a&gt;几个计算机基础概念&lt;/h3&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;计算机存储单位&lt;/li&gt;

      
    
    </summary>
    
      <category term="Java" scheme="https://jy3321.github.io/categories/Java/"/>
    
    
      <category term="数据结构" scheme="https://jy3321.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Java" scheme="https://jy3321.github.io/tags/Java/"/>
    
      <category term="Stack" scheme="https://jy3321.github.io/tags/Stack/"/>
    
      <category term="Heap" scheme="https://jy3321.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>HTTP和HTTPS协议分别是什么</title>
    <link href="https://jy3321.github.io/2019/08/16/http-https/"/>
    <id>https://jy3321.github.io/2019/08/16/http-https/</id>
    <published>2019-08-16T07:49:03.000Z</published>
    <updated>2019-08-22T02:51:00.657Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、什么是协议？"><a href="#一、什么是协议？" class="headerlink" title="一、什么是协议？"></a>一、什么是协议？</h3><hr><p>(网络)协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信。</p><hr><h3 id="二、HTTP协议是什么？"><a href="#二、HTTP协议是什么？" class="headerlink" title="二、HTTP协议是什么？"></a>二、HTTP协议是什么？</h3><hr><p><strong>HTTP协议</strong>是<strong>超文本传输协议</strong>的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。</p><p>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p><p>HTPP有多个版本，目前广泛使用的是HTTP/1.1版本。</p><hr><h3 id="三、HTTP原理"><a href="#三、HTTP原理" class="headerlink" title="三、HTTP原理"></a>三、HTTP原理</h3><hr><p>HTTP是一个基于TCP/IP通信协议来传递数据的协议，传输的数据类型为HTML 文件,、图片文件, 查询结果等。</p><p>HTTP协议一般用于B/S架构（）。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><p>以访问百度：<code>www.baidu.com</code> 为例：</p><ul><li><ol><li><code>客户端</code> 将 <code>www.baidu.com</code> DNS域名解析为服务器IP</li></ol></li><li><ol start="2"><li><code>客户端</code> 发起TCP请求，3次握手建立连接</li></ol></li><li><ol start="3"><li><code>客户端</code>发出HTTP请求</li></ol></li><li><ol start="4"><li><code>服务器端</code> 进行HTTP响应</li></ol></li><li><ol start="5"><li><code>客户端</code>将响应得到的HTML代码和资源值渲染到前端给用户</li></ol></li></ul><hr><h3 id="四、HTTP特点"><a href="#四、HTTP特点" class="headerlink" title="四、HTTP特点"></a>四、HTTP特点</h3><hr><ol><li>http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</li><li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做<strong>Cookie</strong> ,一个叫做<strong>Session</strong>。</li><li>无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</li></ol><hr><h3 id="五、URI和URL的区别"><a href="#五、URI和URL的区别" class="headerlink" title="五、URI和URL的区别"></a>五、URI和URL的区别</h3><hr><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><ul><li>URI：Uniform Resource Identifier 统一资源<strong>标识符</strong></li><li>URL：Uniform Resource Location 统一资源<strong>定位符</strong></li></ul><p>URI 是用来标示 一个具体的资源的，我们可以通过 URI 知道一个资源是什么。</p><p>URL 则是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。</p><hr><h3 id="六、HTTP报文组成"><a href="#六、HTTP报文组成" class="headerlink" title="六、HTTP报文组成"></a>六、HTTP报文组成</h3><hr><h4 id="请求报文构成"><a href="#请求报文构成" class="headerlink" title="请求报文构成"></a>请求报文构成</h4><ol><li>请求行：包括请求方法、URL、协议/版本</li><li>请求头(Request Header)</li><li>请求正文</li></ol><h4 id="响应报文构成"><a href="#响应报文构成" class="headerlink" title="响应报文构成"></a>响应报文构成</h4><ol><li>状态行</li><li>响应头</li><li>响应正文</li></ol><hr><h3 id="七、常见请求方法"><a href="#七、常见请求方法" class="headerlink" title="七、常见请求方法"></a>七、常见请求方法</h3><hr><ul><li>(网络)协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“GET:请求指定的页面信息，并返回实体主体。</li><li>POST:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li><li>HEAD:类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li><li>PUT:从客户端向服务器传送的数据取代指定的文档的内容。</li><li>DELETE:请求服务器删除指定的页面。，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信。</li></ul><p><strong>post和get的区别：</strong></p><ul><li>都包含请求头请求行，post多了请求body。</li><li>get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。</li><li>GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。</li><li>GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。</li></ul><hr><h3 id="八、响应状态码"><a href="#八、响应状态码" class="headerlink" title="八、响应状态码"></a>八、响应状态码</h3><hr><pre><code>访问一个网页时，浏览器会向web服务器发出请求。此网页所在的服务器会返回一个包含HTTP状态码的信息头用以响应浏览器的请求。    </code></pre><h4 id="状态码分类："><a href="#状态码分类：" class="headerlink" title="状态码分类："></a>状态码分类：</h4><ul><li>1XX- 信息型，服务器收到请求，需要请求者继续操作。</li><li>2XX- 成功型，请求成功收到，理解并处理。</li><li>3XX - 重定向，需要进一步的操作以完成请求。</li><li>4XX - 客户端错误，请求包含语法错误或无法完成请求。</li><li>5XX - 服务器错误，服务器在处理请求的过程中发生了错误。</li></ul><h4 id="常见状态码："><a href="#常见状态码：" class="headerlink" title="常见状态码："></a>常见状态码：</h4><ul><li>200 OK - 客户端请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>302 - 临时跳转</li><li>400 Bad Request - 客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li><li>404 - 请求资源不存在，可能是输入了错误的URL</li><li>500 - 服务器内部发生了不可预期的错误</li><li>503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li></ul><hr><h3 id="九、为什么要用HTTPS？"><a href="#九、为什么要用HTTPS？" class="headerlink" title="九、为什么要用HTTPS？"></a>九、为什么要用HTTPS？</h3><hr><p>实际使用中，绝大说的网站现在都采用的是https协议，这也是未来互联网发展的趋势。因为当使用HTTP协议传输一些内容的时候，比如登录过程，访问的账号密码都是明文传输， 这样客户端发出的请求很容易被不法分子截取利用，因此，HTTP协议不适合传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信息非常不安全。</p><h4 id="一般http中存在如下问题："><a href="#一般http中存在如下问题：" class="headerlink" title="一般http中存在如下问题："></a>一般http中存在如下问题：</h4><ol><li>请求信息明文传输，容易被窃听截取。</li><li>数据的完整性未校验，容易被篡改</li><li>没有验证对方身份，存在冒充危险</li></ol><hr><h3 id="十、什么是HTTPS"><a href="#十、什么是HTTPS" class="headerlink" title="十、什么是HTTPS?"></a>十、什么是HTTPS?</h3><hr><p>为了解决上述HTTP存在的问题，就用到了HTTPS。</p><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为<strong>HTTP+SSL/TLS</strong>，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p><p><strong>那么SSL又是什么？</strong></p><p>SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><p><strong>SSL发展史（互联网加密通信）</strong></p><ol><li>1994年NetSpace公司设计SSL协议（Secure Sockets Layout）1.0版本，但未发布。</li><li>1995年NetSpace发布SSL/2.0版本，很快发现有严重漏洞</li><li>1996年发布SSL/3.0版本，得到大规模应用</li><li>1999年，发布了SSL升级版TLS/1.0版本，目前应用最广泛的版本</li><li>2006年和2008年，发布了TLS/1.1版本和TLS/1.2版本</li></ol><hr><h3 id="十、什么是HTTPS-1"><a href="#十、什么是HTTPS-1" class="headerlink" title="十、什么是HTTPS?"></a>十、什么是HTTPS?</h3><hr><p>(网络)协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信。</p><hr><h3 id="十一、浏览器在使用HTTPS传输数据的流程是什么？"><a href="#十一、浏览器在使用HTTPS传输数据的流程是什么？" class="headerlink" title="十一、浏览器在使用HTTPS传输数据的流程是什么？"></a>十一、浏览器在使用HTTPS传输数据的流程是什么？</h3><hr><ol><li>首先<code>客户端</code>通过URL访问服务器建立SSL连接。</li><li><code>服务端</code>收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。</li><li><code>客户端的服务器</code>开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li><code>客户端的浏览器</code>根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li><code>服务器</code>利用自己的私钥解密出会话密钥。</li><li><code>服务器</code>利用会话密钥加密与客户端之间的通信。</li></ol><hr><h3 id="十二、HTTPS的缺点"><a href="#十二、HTTPS的缺点" class="headerlink" title="十二、HTTPS的缺点"></a>十二、HTTPS的缺点</h3><hr><ul><li>HTTPS协议多次握手，导致页面的加载时间延长近50%；</li><li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；</li><li>申请SSL证书需要钱，功能越强大的证书费用越高。</li><li>SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。</li></ul><hr><h3 id="十三、总结HTTPS和HTTP的区别"><a href="#十三、总结HTTPS和HTTP的区别" class="headerlink" title="十三、总结HTTPS和HTTP的区别"></a>十三、总结HTTPS和HTTP的区别</h3><hr><ul><li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。</li><li>http和https使用连接方式不同，默认端口也不一样，http是80，https是443。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;一、什么是协议？&quot;&gt;&lt;a href=&quot;#一、什么是协议？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是协议？&quot;&gt;&lt;/a&gt;一、什么是协议？&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;(网络)协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://jy3321.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://jy3321.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="https://jy3321.github.io/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="https://jy3321.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客Indigo主题安装</title>
    <link href="https://jy3321.github.io/2019/08/13/HexoThemes/"/>
    <id>https://jy3321.github.io/2019/08/13/HexoThemes/</id>
    <published>2019-08-13T13:31:44.000Z</published>
    <updated>2019-08-14T06:57:14.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><hr><p>在之前的博客文章中我们已经搭建了<code>Github+Hexo</code>博客，如果不知道如何搭建，可以参考  <a href="https://jy3321.github.io/2019/07/25/HexoBlog/">Hexo博客搭建</a> 。当我们初步搭建完成自己的个人博客之后，会发现它的默认主题不是很美观，可以在 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo官方主题</a> 可以看到有很多不错的主题，我们选择自己喜欢的来美化自己的博客。在这里推荐我个人比较喜欢的有 <a href="https://github.com/WongMinHo/hexo-theme-miho" target="_blank" rel="noopener"> miho</a> 、<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a> ，这两个主题都是我自己用过的，现在自己使用的主题是 <code>indigo</code> ,下面也是用这个主题作为教程。</p><hr><h3 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h3><hr><p>安装需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上。<br>我们可以在 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a> 的主页上获取到它的https地址：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/13/HexoThemes/F6UAT2M{[$SYIXF9C@)XF(1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在 Hexo 根目录，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yscoder/hexo-theme-indigo.git themes/indigo</span><br></pre></td></tr></table></figure><pre><code>这个命令要在博客文件夹的根目录右击鼠标打开Git Bash输入命令，其中themes/indigo就是会在博客文件夹根目录中的themes新建一个indigo文件夹存放clone下来的主题，以后indigo主题相关的东西都是存放在这个目录下。简单讲这个命令就是 git clone +主题在github中的https +themes/indig</code></pre><hr><h3 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h3><hr><h4 id="安装Less"><a href="#安装Less" class="headerlink" title="安装Less"></a>安装Less</h4><p>主题默认使用 less 作为 css 预处理工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-less --save</span><br></pre></td></tr></table></figure><h4 id="安装Feed"><a href="#安装Feed" class="headerlink" title="安装Feed"></a>安装Feed</h4><p>用于生成 rss</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><h4 id="安装Json-content"><a href="#安装Json-content" class="headerlink" title="安装Json-content"></a>安装Json-content</h4><p>用于生成静态站点数据，用作站内搜索的数据源。这个在博客刚开始搭建安装依赖的时候，大部分都安装了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-json-content --save</span><br></pre></td></tr></table></figure><h4 id="安装QRCode"><a href="#安装QRCode" class="headerlink" title="安装QRCode"></a>安装QRCode</h4><p>用于生成微信分享二维码。网页分享中微信可以动态生成该网页的分享分二维码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-helper-qrcode --save</span><br></pre></td></tr></table></figure><hr><h3 id="Hexo新建文件"><a href="#Hexo新建文件" class="headerlink" title="Hexo新建文件"></a>Hexo新建文件</h3><hr><p>新建一篇文章进行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"PageName"</span></span><br></pre></td></tr></table></figure><hr><h3 id="开启标签页"><a href="#开启标签页" class="headerlink" title="开启标签页"></a>开启标签页</h3><hr><p>开启标签页，会新建一个名为tags文件夹，文件夹有一个index.md文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>修改 hexo/source/tags/index.md 的元数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: tags</span><br><span class="line"> comments: <span class="literal">false</span></span><br><span class="line"> ---</span><br></pre></td></tr></table></figure><hr><h3 id="开启分类页"><a href="#开启分类页" class="headerlink" title="开启分类页"></a>开启分类页</h3><hr><p>同样的开启分类页，也会新建一个名为categories的文件夹，文件夹有一个index.md文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>修改  hexo/source/categories/index.md </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: categories</span><br><span class="line"> comments: <span class="literal">false</span></span><br><span class="line"> ---</span><br></pre></td></tr></table></figure><p>修改完之后的目录应该如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/13/HexoThemes/9D1W8FI5V490KX56N$0JS_T.png" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><hr><h4 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h4><p>在你博客的根目录下找到<code>_config.yml</code> 文件，将其中的 <code>theme</code> 属性改为 <code>indigo</code>  :</p><p><a href="123.png"></a></p><h4 id="文件清理"><a href="#文件清理" class="headerlink" title="文件清理"></a>文件清理</h4><p>清理之前在public文件夹中生成的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h4 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h4><p>在public文件夹中生成html、css、xml等前台静态文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h4 id="开启本地服务"><a href="#开启本地服务" class="headerlink" title="开启本地服务"></a>开启本地服务</h4><p>你就可以在<code>http://localhost:4000/</code>中预览</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><hr><p>到此， <code>hexo</code> 博客的 <code>indigo</code> 主题就安装完毕了。类似的，你也可以去尝试安装其它的主题。安装方法都是将主题克隆到自己的 <code>themes</code> 文件夹下，然后安装相应的依赖，配置并启用主题就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在之前的博客文章中我们已经搭建了&lt;code&gt;Github+Hexo&lt;/code&gt;博客，如果不知道如何搭建，可以参考
      
    
    </summary>
    
      <category term="Hexo" scheme="https://jy3321.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://jy3321.github.io/tags/Hexo/"/>
    
      <category term="GitHub" scheme="https://jy3321.github.io/tags/GitHub/"/>
    
      <category term="Indigo" scheme="https://jy3321.github.io/tags/Indigo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客插入图片的问题</title>
    <link href="https://jy3321.github.io/2019/08/12/HexoPictures/"/>
    <id>https://jy3321.github.io/2019/08/12/HexoPictures/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-08-13T13:30:40.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hexo博客插入图片"><a href="#Hexo博客插入图片" class="headerlink" title="Hexo博客插入图片"></a>Hexo博客插入图片</h3><p>在编写自己博客的时候肯定要加入图片方便理解。但是当我把图片加入文章（直接复制进文章的时候），他的提示是这样的:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/12/HexoPictures/ZU{2$]5RKXPAT2XUPUJEJI7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>图片的插入格式是 <code>！[]()</code>  ，其中<code>[ ]</code>内是图片的标题，一般为图片名，也可以不填，<code>()</code>  里是图片的地址。当我们这样插入图片的时候，我们是可以在自己的文章中看到的，但是上传github后发现在网页上并不能看到。就是这个路径的问题。关于插入图片的路径，有两种方式。</p><h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。对于source/images/image.jpg这张图片可以用以下语法访问到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure><p>这样填写路径的图片，既可以在首页内容中访问到，也可以在文章正文中访问到。我的博客的首页背景，文章首页的图片，用的都是这个路径。</p><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。<br>文章的目录可以通过配置博客根目录下的<code>_config.yml</code>来生成。</p><ul><li>1.将<code>_config.yml</code>文件中的配置项<code>post_asset_folder</code>设为<code>true</code>后</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/12/HexoPictures/21I2{[NG0OS@GE7}67A7~GQ.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><ul><li>2.打开Git Bash，下载一个插件（需要等待一阵..）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><ul><li>3.完成安装后用<code>hexo</code>新建文章的时候会发现<code>_posts</code>目录下面会多出一个和文章名字一样的文件夹。</li></ul><p>然后你在写文章的时候，关于这篇文章的图片，就可以放在这个相同名字的文件夹中。比如你在文件夹中存了一张名为<code>image.jpg</code>的图片，你就可以直接使用markdown的引用进行使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure><p>这样填写路径的图片，只能在文章中显示，无法在首页中正常显示，但是其实对于文章中的图片，就已经可以了。<br>如果你想要图片在文章和首页中同时显示，可以使用标签插件语法。<code>_posts/post_name/image.jpg</code>这张照片可以用以下方式访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简而言之，就是在你使用<code>hexo n</code>新建一篇文章的时候，会自动在你文章的同一目录下新建一个与文章名相同名字的文件夹，你可以把这篇文章的相关图片都放在这个文件夹下，然后用<code>![](image.jpg)</code>的方式引用它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Hexo博客插入图片&quot;&gt;&lt;a href=&quot;#Hexo博客插入图片&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客插入图片&quot;&gt;&lt;/a&gt;Hexo博客插入图片&lt;/h3&gt;&lt;p&gt;在编写自己博客的时候肯定要加入图片方便理解。但是当我把图片加入文章（直接复制
      
    
    </summary>
    
      <category term="Hexo" scheme="https://jy3321.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://jy3321.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客如何添加评论功能</title>
    <link href="https://jy3321.github.io/2019/08/12/HexoComments/"/>
    <id>https://jy3321.github.io/2019/08/12/HexoComments/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-08-14T05:18:59.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>想要让自己的博客能够进行互动，所以要添加评论功能。自己也是捣鼓了一会才终于实现。</p><h3 id="评论系统的选择"><a href="#评论系统的选择" class="headerlink" title="评论系统的选择"></a>评论系统的选择</h3><hr><ul><li>多说：貌似已经关闭了</li><li>disqus：需要翻墙访问才行</li><li>友言:不支持https协议，而github使用的是https协议</li><li>网易云跟帖：需要域名</li><li>搜狐畅言：需要备案，不然只能使用15天</li><li>来比力：很多人都推荐使用这个，自己尝试了下确实可行。但是加载速度是真的是太慢了。。。</li></ul><p>在GG了一堆评论系统后，最后发现了一个叫 <code>valine</code> 的评论系统， <code>indigo</code>主题其实也配置了这个系统。</p><hr><h3 id="Valine评论系统安装"><a href="#Valine评论系统安装" class="headerlink" title="Valine评论系统安装"></a>Valine评论系统安装</h3><hr><p>首先我们要去 <code>leancloud</code> 官网注册一个账号，由于国内版的最近好像也要GG，所以我们选择注册 <a href="https://us.leancloud.cn/login.html#/signin" target="_blank" rel="noopener">国际版Valine</a> ,注册成功之后创建一个应用，选择<code>开发版</code>即可，在<code>应用Key</code>中我们可以看到你的 <code>AppID</code> 和 <code>AppKey</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/08/12/HexoComments/40K$@D1EWKG7}[WJW8$4_7T.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>打开主题文件夹中的配置文件 <code>_config.yml</code> ，填写其中的<code>valine</code>，例如我的：</p><p><img src="/2019/08/12/HexoComments/G0_%602%0C3MTHM2VO%7DAYHW94.png" alt></p><p>最后，在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去。</p><p>然后你的评论系统应该就可以用了。<br>以上是针对例如 <code>indigo</code> 等自带 <code>valine</code> 配置文件的博客主题的安装方法。如果你的博客主题中没有 <code>valine</code>，你也可以去 <a href="https://valine.js.org/" target="_blank" rel="noopener">Valine官网</a> 阅读以下文档进行相关配置，只需要添加几行代码，操作起来也是很简单的。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;想要让自己的博客能够进行互动，所以要添加评论功能。自己也是捣鼓了一会才终于实现。&lt;/p&gt;
&lt;h3 id=&quot;评论系统的选择&quot;&gt;
      
    
    </summary>
    
      <category term="Hexo" scheme="https://jy3321.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://jy3321.github.io/tags/Hexo/"/>
    
      <category term="Valine" scheme="https://jy3321.github.io/tags/Valine/"/>
    
  </entry>
  
</feed>
