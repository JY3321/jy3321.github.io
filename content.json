{"meta":{"title":"骄阳焦洋","subtitle":"明明如月，何时可掇？忧从中来，不可断绝。","description":null,"author":"焦洋","url":"https://jy3321.github.io","root":"/"},"pages":[{"title":"","date":"2020-10-03T10:25:27.836Z","updated":"2020-10-03T10:25:27.836Z","comments":true,"path":"about/index.html","permalink":"https://jy3321.github.io/about/index.html","excerpt":"","text":"关于我焦洋，男（直男），一名刚入坑的菜鸟，新疆哈密人；//博客是大学的时候建的; 主要学习方向Java；//刚毕业的时候是想从事java方向的来着;//结果毕业后第一份工作现在主要是SQL server数据库方面; 掌握操作系统、计算机网络等计算机基础；掌握 数据结构 与常见算法；熟悉使用 Spring、SpringMVC 、MyBatis等主流框架；熟悉使用 MySQL 、了解Redis；对服务器端、数据分析等技能有所了解；//这些都是没毕业刚建博客的时候写的，现在大概可以忽略了; 热爱开源项目、热爱新技术、热爱新事物； 关于工作目标工作城市：北京//好吧刚毕业的时候，也曾梦想仗剑走天涯;//但是太菜了，加上其它个人原因，现已回家种田; 现工作城市：新疆，具体在哈密/乌鲁木齐; 关于学习本科在读 中国地质大学（北京） 软件工程专业;//2020.07月正式毕业，离开地大离开北京了; Keep Moving… 关于爱好热爱运动，尤其喜爱跑步;喜欢打游戏，对所有的游戏都充满着兴趣;曾经也热爱播音主持，或许当初没报软件工程，可能会去报播音主持;//现在算是自己的一个小爱好吧，嗯，但是唱歌跑调; 关于最喜欢的诗歌 短歌行 [魏晋] 曹操对酒当歌，人生几何！譬如朝露，去日苦多。慨当以慷，忧思难忘。何以解忧？唯有杜康。青青子衿，悠悠我心。但为君故，沉吟至今。呦呦鹿鸣，食野之苹。我有嘉宾，鼓瑟吹笙。明明如月，何时可掇？忧从中来，不可断绝。越陌度阡，枉用相存。契阔谈讌，心念旧恩。月明星稀，乌鹊南飞。绕树三匝，何枝可依？山不厌高，海不厌深。周公吐哺，天下归心。 联系我 Blog: jy3321.com GitHub: JY3321 Email: jiaoyang3321@163.com QQ:821535576 网易云音乐:骄阳焦洋"},{"title":"","date":"2019-08-13T03:18:12.897Z","updated":"2019-08-13T03:18:12.897Z","comments":true,"path":"categories/index.html","permalink":"https://jy3321.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-13T03:18:27.488Z","updated":"2019-08-13T03:18:27.488Z","comments":true,"path":"tags/index.html","permalink":"https://jy3321.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"IDEA报错-Message-前言中不允许有内容","slug":"IDEA报错-Message-前言中不允许有内容","date":"2021-10-21T08:17:03.000Z","updated":"2021-10-21T09:50:54.634Z","comments":true,"path":"2021/10/21/IDEA报错-Message-前言中不允许有内容/","link":"","permalink":"https://jy3321.github.io/2021/10/21/IDEA报错-Message-前言中不允许有内容/","excerpt":"","text":"Message-前言中不允许有内容 将文件编码格式改为NO BOM，错误解决 选择with no BOM,注意：这个设置只修改了当前项目，如果还需要为其他项目设置，在other settings 为新的项目进行同样的设置即可、","categories":[{"name":"IDEA","slug":"IDEA","permalink":"https://jy3321.github.io/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://jy3321.github.io/tags/IDEA/"},{"name":"报错","slug":"报错","permalink":"https://jy3321.github.io/tags/报错/"}],"author":"焦洋"},{"title":"每日学习","slug":"每日学习","date":"2021-02-02T15:02:53.000Z","updated":"2021-02-02T15:10:47.136Z","comments":true,"path":"2021/02/02/每日学习/","link":"","permalink":"https://jy3321.github.io/2021/02/02/每日学习/","excerpt":"","text":"2020.02.021.java基础语法1.java是一种跨平台的纯面向对象的语言，而.Net是一种跨语言的平台​ 对照关系应该为​ Java：语言 JDK：平台​ C#：语言 .Net：平台即通常我们所说的语言，都是指的语言本身，而.Net 的语言是指的平台，.Net用的语言是C#,也就是说C#和.Net是一个东西，不要问学C#好还是.Net好这样让人笑话的问题。 ​","categories":[{"name":"学习日记","slug":"学习日记","permalink":"https://jy3321.github.io/categories/学习日记/"}],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"https://jy3321.github.io/tags/学习日记/"}],"author":"焦洋"},{"title":"git bash中的快捷键","slug":"git-bash中的快捷键","date":"2020-10-04T03:22:19.000Z","updated":"2020-10-05T05:36:10.914Z","comments":true,"path":"2020/10/04/git-bash中的快捷键/","link":"","permalink":"https://jy3321.github.io/2020/10/04/git-bash中的快捷键/","excerpt":"","text":"命令 pwd (Print Working Directory) 查看当前目录 cd (Change Directory) 切换目录，如 cd /etc ls (List) 查看当前目录下内容，如 ls -al mkdir (Make Directory) 创建目录，如 mkdir blog touch 创建文件，如 touch index.html cat 查看文件全部内容，如 cat index.html more/less 查看文件，如more /etc/passwd、less /etc/passwd rm (remove) 删除文件，如 rm index.html、rm -rf blog rmdir (Remove Directory) 删除文件夹，只能删除空文件夹，不常用 mv (move) 移动文件或重命名，如 mv index.html ./demo/index.html cp (copy) 复制文件，cp index.html ./demo/index.html head 查看文件前几行，如 head -5 index.html tail 查看文件后几行 –n –f，如 tail index.html、tail -f -n 5 index.html tab 自动补全，连按两次会将所有匹配内容显示出来 history 查看操作历史 \\&gt; 和&gt;&gt;重定向，如echo hello world! &gt; README.md，&gt;覆盖 &gt;&gt;追加 wget 下载，如wget https://nodejs.org/dist/v4.4.0/node-v4.4.0.tar.gz tar 解压缩，如tar zxvf node-v4.4.0.tar.gz curl 网络请求，如curl http://www.baidu.com whoami 查看当前用户 | 管道符可以将多个命令连接使用，上一次（命令）的执行结果当成下一次（命令）的参数。 grep 匹配内容，一般结合管道符使用 快捷键光标ctrl+b 前移至一个字符(backward)ctrl+f 后移至一个字符(forward)alt+b 前移至一个单词alt+f 后移至一个单词ctrl+a 跳转至行首ctrl+e 跳转至行尾ctrl+x 行首/当前位置光标跳转 编辑alt+. 粘帖上一次命令最后的参数ctrl+h 删除光标前一个字符（backspace）ctrl+d 删除光标后一个字符（delete）ctrl+w 删除光标左侧单词alt+d 删除光标右侧单词ctrl+u 删除光标左侧所有字符ctrl+k 删除光标右侧所有字符ctrl+l 清屏ctrl+shift+c 复制(ctrl+ins)ctrl+shift+v 粘贴(shift+ins) 命令ctrl+n 下一条命令ctrl+p 上一条命令shift+PageUp 向上翻页shift+PageDown 向下翻页ctrl+r 查找命令历史记录，输入keyword多次ctrl+r可返回下一个匹配项 touch 新建文件mkdir 新建目录rm 删除文件rm -r 删除文件夹(recusive)mv 移动文件ls 列出文件pwd 打印工作目录cd 改变目录reset 清屏","categories":[{"name":"Git","slug":"Git","permalink":"https://jy3321.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://jy3321.github.io/tags/Git/"}],"author":"焦洋"},{"title":"SQL Server常用语句记录","slug":"SQL-Server常用语句记录","date":"2020-10-03T11:00:41.000Z","updated":"2021-05-04T04:14:50.559Z","comments":true,"path":"2020/10/03/SQL-Server常用语句记录/","link":"","permalink":"https://jy3321.github.io/2020/10/03/SQL-Server常用语句记录/","excerpt":"","text":"写在前面新的工作跟数据库接触的比较多，而且主要是SQL Server，在此记录一些常用的操作和查询方法，便于日后复习使用。 临时表的建法 12select * into #临时表名 from 你的表;select * into ##临时表名 from 你的表; 注：以上的#代表局部临时表，##代表全局临时表 查询字段第几个字是某个指定字符可用substring函数来查询；如： 现在要查询第二位zhi字符为“s”的数据，dao可用如下语句： 1select * from test where substring(STR,2,1)='s' 结果截图： substring函数说明：substring函数需要三个参数，其中第一个参数是要截取的字符串，第二个参数是要查询字符串的起始位，第三个参数为截取的字符长度。 查询某个表所有的列名1select name from syscolumns where id = object_id('表名'); 也可以计算列的个数： 1select count(name) from syscolumns where id = object_id('表名'); 变量的声明、设置、使用、输出声明了三个变量：typeid、parentid、name，数据类型分别为：int、int、varchar(50) 1declare @typeid int,@parentid int,@name varchar(50) ; 设置变量：name 的值为：成都市 1set @name='成都市'; 使用变量，变量查询赋值：使用 @name 变量，将查询出来的 typeid 字段的数据赋值给 @typeid 变量 1select @typeid = typeid from [logging].[dbo].[SYS_CODE] where name = @name; 使用下面的代码直接输出变量： 1print 'typeid：'+@typeid+' name：'+ @name SQL Server 报错： 这是因为SQL Server 不能直接将 int 类型的数据转换为 varchar ，使用 cast 可以进行类型转换：-@typeid 转换的变量/数据 as varchar转换的类型 1cast(@typeid as varchar(50)) 写成下面这样就可以正常输入结果了 1print 'typeid：'+cast(@typeid as varchar(50)) +' name：'+ @name declare的用法（非局部变量，在批处理中仍有用）平时写SQL查询、存储过程都是凭着感觉来，没有探究过SQL的具体语法，一直都是按以前一套往SQL上模仿，前几天项目中碰到一个问题引起了我对declare定义变量的作用域的兴趣。局部变量，在if中如果我们定义一个变量的话他的作用到if结束为止，if外是不识别这个变量的，else里都不能使用，简单的写一下。 1234if (true)&#123;Int32 i = 1; Console.WriteLine(i);&#125; 这个i的作用域就是if里面，如果我们在if外面用这个变量 12345if (true)&#123; Int32 i = 1; Console.WriteLine(i);&#125;Console.WriteLine(i); 那第二条输出语句会报错 1The name 'i' does not exist in the current context 说明已经出了i的作用域了。那么我们要是在sql写这么一段代码会是什么情况呢？首先写在if内 123456IF 1=1BEGIN DECLARE @test VARCHAR SET @test='1' PRINT 'in if:'+@testEND 运行看结果输出in if:1这是可以预想的结果。那我们在if外面使用变量@test试试。 1234567IF 1=1BEGIN DECLARE @test VARCHAR SET @test='1' PRINT 'in if:'+@testENDPRINT 'out if:'+@test 这样会是什么结果呢，不知道大家怎么想的，以我的大脑顺势就想到这应该报错啊，出了变量的作用域了。实际结果不仅没报错而且@test的值还在。 12in if:1out if:1 看见这个结果当时我很郁闷，SQL太出人意料了。在SQL SERVER 2005的帮助文档里关于declare的帮助里发现这么一句话，备注的第三行“局部变量的作用域是其被声明时所在批处理”Msdn的地址：http://msdn.microsoft.com/zh-cn/library/ms188927.aspx这行字在这么一大篇中还真挺不引人瞩目。现在我们知道原来declare变量的作用域是所在的批处理，if阻断不了它的作用域，那上面我们的代码if内外的代码都在一个批处理中，所以@test都是可用的且if里面设置的值还在。下面我改造一下代码，SQL中是以GO语句来区分批处理的 12345678IF 1=1BEGIN DECLARE @test VARCHAR SET @test='1' PRINT 'in if:'+@testENDGOPRINT 'out if:'+@test 这样就会报错。","categories":[{"name":"SQL Server","slug":"SQL-Server","permalink":"https://jy3321.github.io/categories/SQL-Server/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://jy3321.github.io/tags/SQL/"}],"author":"焦洋"},{"title":"重启大法好（记最近一件又蠢又好笑的事）","slug":"重启大法好（记最近一件又蠢又好笑的事）","date":"2020-05-10T06:52:36.000Z","updated":"2020-05-10T07:08:13.604Z","comments":true,"path":"2020/05/10/重启大法好（记最近一件又蠢又好笑的事）/","link":"","permalink":"https://jy3321.github.io/2020/05/10/重启大法好（记最近一件又蠢又好笑的事）/","excerpt":"","text":"昨天晚上自己项目好好的，今天跑的时候，项目一运行主页就是自己的页面找不到了的页面，由于之前项目刚在本地运行的时候也出现过这样的问题，就怀疑是数据库配置有问题，反复改了很多次，甚至把项目重新导入从头重新建配置，反复多次尝试多种方式，无果。后来直接去看看数据库。打开Navicat时发现报错ERROR 2013：Lost connection to MySQL server，意思就是我数据库都连接不上了？ ？去网上查了这个报错怎么解决，方法试了都无果，知道看到一篇帖子里的说法： 跟我一样，各种方法尝试无果，然后，重启？？行吧我试一下，卧槽？？好吧就是这样，重启一下电脑项目就能正常访问数据库，显示内容了。 就这样一个问题让我郁闷了一早上，自己真的是又想笑又无奈。也该反思一下自己是不是学傻了，思维都固化了，明明前一天晚上可以运行，就说明代码没有问题，今天出问题应该从环境上找问题，而不是怀疑自己去改自己的配置和代码。。 记得之前去看摩天营救的时候，整部电影啥都没记住，就记住了那句重启就好了的梗。没想到今天自己也成了这个梗。嗯，以后要记得，重启大法好。哈哈。","categories":[{"name":"日常","slug":"日常","permalink":"https://jy3321.github.io/categories/日常/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://jy3321.github.io/tags/日常/"}],"author":"焦洋"},{"title":"常用数据库JDBC驱动名称及URL","slug":"常用数据库JDBC驱动名称及URL","date":"2020-05-10T06:46:36.000Z","updated":"2020-05-10T06:49:30.402Z","comments":true,"path":"2020/05/10/常用数据库JDBC驱动名称及URL/","link":"","permalink":"https://jy3321.github.io/2020/05/10/常用数据库JDBC驱动名称及URL/","excerpt":"","text":"为方便使用JDBC连接各种数据库，特对常用的数据库driverClassName和url进行整理，方便自己查阅和使用。 需要注意的是MySQL版本不同驱动和URL也不一致，并且MySQL 6.0 及其以上的版本url后面必须加上参数serverTimezone=UTC；不加则会报错。 除此之外还可选加参数(多个参数之间用&amp;连接)：useUnicode=true；characterEncoding=utf8 ; useSSL=false,但一般建议加上，如果不加useSSL不会出错但有警告。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://jy3321.github.io/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://jy3321.github.io/tags/数据库/"}],"author":"焦洋"},{"title":"最近二三事","slug":"twoOrThreeRecentEvents","date":"2019-11-26T11:57:13.000Z","updated":"2020-05-10T07:09:53.687Z","comments":true,"path":"2019/11/26/twoOrThreeRecentEvents/","link":"","permalink":"https://jy3321.github.io/2019/11/26/twoOrThreeRecentEvents/","excerpt":"","text":"其实最近有一段时间没有捣鼓自己的博客了，各种原因吧，自己反省了一下最近这段时间做的事，感觉自己又把最宝贵的时间浪费了过去。。写点东西总结一下最近的自己吧。 几个月前，自己满心欢喜的搭建起了这个博客，然后特别特别的想让自己的博客里有文章，就去看别人的博客，学着写东西，有些内容自己甚至不是很理解，觉得别人写的特别好就写在了自己的博客里，觉得很有成就感很有满足感，但是完全忘记了自己搭建这个博客的最初目的——记录自己的学习，帮助自己更好的学习。因为有些内容自己现在看甚至都已经忘记了当时为什么那样总结为什么那样写，只是当时为了写博客而写的，并没有深入的去理解去学习，比如之前明明有看了内存模型相关的知识甚至写了博客，在面试字节的时候被问到回答的还是一塌糊涂，甚至在问到类加载机制的时候，我竟然忘了static初始化顺序，简单的一道判断初始化顺序的题也能回答错误（不知道当时面试官是不是都想嘲笑我…反正我觉得自己当时好丢人…static是在类被初始化的时候执行的，java初始化正确的顺序应该是：父类静态成员变量→父类静态代码块→子类静态成员变量→子类静态代码块→父类非静态成员变量→父类非静态代码块→父类构造函数→子类非静态成员变量→子类非静态代码块→子类构造函数）。自己光顾着看光顾着写，而忘记了更重要的要自己去理解去思考。在秋招经历了几个大厂的惨烈面试之后，我自闭了很久。自己差的真的太多了，除了基础知识差，要补充要学习的东西也真的太多，以至于在后面的面试，我都没有信心再去参加面试，自己一度放弃了秋招。。 一直到最近一个月，和自己一起开始准备秋招的室友，拿到了offer，工资极其可观诱人，酸死了。。看看人家，在酸的同时，仿佛又给自己打了鸡血，同样都是一个学校一个班甚至一个宿舍的，他能做到，我为什么不能做到。也就是最近开始，自己才又开始正视自己的问题，去LeetCode上刷题，去牛客上看面经，拿出以前买的书一页一页的看，正如室友讲的，学就完事了，血本有归就行。也许秋招真的要错过了，但是努力，应该会有结果的。 自己这段时间又对博客感兴趣起来了，想重新尝试下别的框架搭博客，觉Hexo没有后台没有自带的文章编辑器，使用起来好像没那么方便？原来觉得好看的排版和主题，现在看起来好像也没那么顺眼了？想试试Hago和WordPress？？好像Unity也蛮好玩的，自己也想试试学着做小游戏？？？。。。可是要找工作啊大哥！在秋招的时候发现一堆好玩的东西，我发现自己老是在一些关键时刻发现一些好玩有意思的事，然后去分心影响正事，为什么没早点发现啊。不过还要吐槽一下学校，大四了还是满课，课程作业全是报告，上万字的那种，然后还有各种各样的图。。无奈。争取把这段时间熬过去吧，秋招让我太痛苦了。后面调整好心态继续努力复习，刷题看知识点，看看秋招补录，实在不行准备春招，自己多准备准备应该也会有机会的吧。抽空把课程作业补完，最近可能不太更新自己的博客了，如果要更，也要保证后面更新的东西都会是自己思考理解了的东西再进行更新。后面可能会重新搭一下博客，如果找工作能顺利一点的话，我是说如果，再慢慢捣鼓吧。。","categories":[{"name":"日常","slug":"日常","permalink":"https://jy3321.github.io/categories/日常/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://jy3321.github.io/tags/日常/"}],"author":"焦洋"},{"title":"快速理解UML类图中各个类之间的关系","slug":"UMLclass","date":"2019-11-22T02:55:25.000Z","updated":"2020-05-10T07:11:18.842Z","comments":true,"path":"2019/11/22/UMLclass/","link":"","permalink":"https://jy3321.github.io/2019/11/22/UMLclass/","excerpt":"","text":"从一个示例开始 我们通过一个例子来理解 车的类图结构为&lt; abstract &gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 下面我们将介绍这六种关系； 类之间的关系 泛化关系(generalization)类的继承结构表现在UML中为：泛化(generalize)与实现(realize)： 继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..) eg：自行车是车、猫是动物 泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）； eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系； 注：最终代码中，泛化关系表现为继承非抽象类； 实现关系(realize)实现关系用一条带空心箭头的虚线表示； eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解） 注：最终代码中，实现关系表现为继承抽象类； 聚合关系(aggregation)聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成； 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在； 组合关系(composition)组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成； 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系(association)关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 注：在最终代码中，关联对象通常是以成员变量的形式实现的； 依赖关系(dependency)依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系； 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性； 感谢：https://design-patterns.readthedocs.io/","categories":[{"name":"UML","slug":"UML","permalink":"https://jy3321.github.io/categories/UML/"}],"tags":[{"name":"UML","slug":"UML","permalink":"https://jy3321.github.io/tags/UML/"}],"author":"焦洋"},{"title":"值得你读的博客（一起挖宝吧）","slug":"blogsURL","date":"2019-09-08T10:50:51.000Z","updated":"2019-11-22T03:26:32.916Z","comments":true,"path":"2019/09/08/blogsURL/","link":"","permalink":"https://jy3321.github.io/2019/09/08/blogsURL/","excerpt":"","text":"前言在学习的过程中挖到了大量的宝贝。。。。 话不多说，在这里跟大家分享一下目前挖到的宝，后续再发现比较好的博客会持续更新 一起学习加油吧！链接 五月的仓颉是我第一个关注的博主，大佬的文章勾起了我想自己写博客的欲望https://www.cnblogs.com/xrq730/ JavaGuide ，github上优秀的java知识总结，我自己目前也在跟着学习和复习https://snailclimb.gitee.io/javaguide/#/ 图说设计模式https://design-patterns.readthedocs.io/zh_CN/latest/ Java成神之路技术整理https://my.oschina.net/javaroad/blog/1793570 白话算法系列的作者https://blog.csdn.net/MoreWindows/article/details/6657829 菜鸟联盟，这个应该不算是博客，而是一个比较好的网站吧，应该大家在搜索某些知识的时候多多少少都打开过。各种基础知识都可以在上面学习，他还提供了很多小工具，比如在线编辑器等，都很好用https://www.runoob.com/ java各种基础知识点的汇总https://www.cnblogs.com/qdhxhz/default.html?page=2 java进阶合集https://blog.csdn.net/sunhuaqiang1/article/category/3130685 关于jvm可以看看这个博客http://hllvm.group.iteye.com/group/wiki/?category_id=316 Intellij Idea相关的各种使用相关问题，从注册到开发，基本配置，如何配置使用方便，等等很多实用的小技巧及使用过程中产生的各种各样的问题https://blog.csdn.net/column/details/15222.html 关于java的IO可以看这个http://ifeve.com/java-io/ 多线程，集合，I/O和异常等可以看这个博客，而且都是系列化的文章，对于我这种推崇系统化学习的人来说，真的很不错http://www.cnblogs.com/skywang12345/category/455711.html 超简单的 MySQL 数据库教程https://blog.csdn.net/column/details/16138.html 关于Spring的几篇文章写得很详细，阅读量很高https://blog.csdn.net/lutianfeiml 快速学习 Spring Boot 技术栈https://blog.csdn.net/column/details/15149.html 介绍maven基础以及扩展知识https://blog.csdn.net/column/details/maven-force.html 主要集中在Java Web本身的技术解释和剖析，不涉及任何框架的技术https://blog.csdn.net/column/details/15759.html 设计模式是一个程序员迟早要掌握的技能https://blog.csdn.net/column/details/pattern.html CSDN排名第七，神一样的人物https://blog.csdn.net/notbaron/article/category/6026793 这绝对是java大神级别的人物，java学习者必须关注https://blog.csdn.net/sunhuaqiang1/article/category/3130685 《成神之路系列文章》系列作者，阿里大神Hollis的博客怎么可以错过http://www.hollischuang.com/archives/1001 分享技术，品味人生，来自纯洁的微笑，学习SpringBoot和Cloud必须关注的博客http://www.ityouknow.com/ 学习设计模式，这是很好的一个博客http://www.cnblogs.com/java-my-life/ java编程及工程的一些话题https://www.cnblogs.com/qdhxhz/default.html?page=2 （未完待续，持续更新）","categories":[{"name":"Blogs","slug":"Blogs","permalink":"https://jy3321.github.io/categories/Blogs/"}],"tags":[{"name":"Blogs","slug":"Blogs","permalink":"https://jy3321.github.io/tags/Blogs/"}],"author":"焦洋"},{"title":"JSP页面之间传值的方法总结","slug":"JSPPassing","date":"2019-09-04T01:07:33.000Z","updated":"2019-09-04T02:34:31.991Z","comments":true,"path":"2019/09/04/JSPPassing/","link":"","permalink":"https://jy3321.github.io/2019/09/04/JSPPassing/","excerpt":"","text":"B/S页面间通信 HTTP是无状态的协议。Web页面本身无法向下一个页面传递信息，如果需要让下一个页面得知该页面中的值，除非通过服务器。因此，Web页面保持状态并传递给其它页面，是一个重要的技术。 Web页面之间传递数据，是Web程序的重要功能，需要：客户端界面（输入信息） → 发送数据 → 服务器 → 响应 → 客户端界面（显示信息） 在HTTP协议中一共有 4种方法来完成这件事情： URL传值； 表单传值； Cookie方法； Session方法； URL传值 优点：简单性和平台支持的多样性（浏览器都支持URL）。缺点： 传输的数据只能是字符串，对数据类型具有一定的限制； 传输数据的值会在浏览器地址栏里面被看到，从保密的角度讲，这是不安全的。特别是秘密性要求比较严格的数据，比如说密码。 表单传值 优点URL中不会被看到缺点 和URL方法类似，该方法传输的数据，也只能是字符串，对数据类型具有一定的限制； 传输数据的值虽然可以保证在浏览器地址栏里不被看到，但是在客户端源代码里面也会被看到，从保密的角度讲，这是不安全的。对于是秘密性要求比较严格的数据，比如说密码来说还是不建议用表单来进行传输。 Cookie方法 Cookie是一个小的文本数据，由服务器端生成，发送给客户端浏览器，客户端浏览器如果设置为启用 cookie，则会将这个小文本数据保存到其目录下的文本文件内。客户端下次登录同一网站，浏览器则会自动将 Cookie 读入之后，传给服务器端。服务器端可以对该 Cookie 进行读取并验证(当然也可以不读取)。 一般情况下，Cookie 中的值是以key-value的形式进行表达的。页面间的传值可以用 Cookie来进行。即：在第一个页面中，将要共享的变量值保存在客户端 Cookie 文件内，在客户端访问第二个页面时，由于浏览器自动将 Cookie读入之后，传给服务器端，因此只需要第二个页面中，由服务器端页面读取这个 Cookie 值即可。 问题 在客户端的浏览器上，我们看不到任何的和传递的值相关的信息，说明在客户端浏览器中，Cookie 中的数据是安全的。 但是就此也不能说 Cookie 是完全安全的。因为 Cookie 是以文件形式保存在客户端的，客户端存储的 Cookie 文件就可能敌方获知。如果将用户名、密码等敏感信息保存在Cookie内，在用户离开客户机时不注意清空，这些信息容易泄露，因此Cookie在保存敏感信息方面具有潜在危险。可以很清楚地看到。 Cookie的危险性来源于Cookie的被盗取。目前盗取的方法有多种： 利用跨站脚本技术，将信息发给目标服务器；为了隐藏跨站脚本的 URL，甚至可以结合 Ajax(异步Javascript 和 XML技术)在后台窃取 Cookie； 通过某些软件，窃取硬盘下的 Cookie。如前所述，当用户访问完某站点后，Cookie文件会存在机器的某个文件夹(如 C:\\Documents and Settings\\用户名\\Cookies)下，因此可以通过某些盗取和分析软件来盗取 Cookie。具体步骤如下： (1)利用盗取软件分析系统中的 Cookie，列出用户访问过的网站； (2)在这些网站中寻找攻击者感兴趣的网站； (3)从该网站的 Cookie 中获取相应的信息。不同的软件有不同的实现方法，有兴趣的读者可以在网上搜索相应的软件； 利用客户端脚本盗取 Cookie。在 Javascript 中有很多 API 可以读取客户端 Cookie，可以将这些代码隐藏在一个程序(如画图片)中，很隐秘地得到 Cookie 的值，不过，这也是跨站脚本的一种实现方式。以上的问题并不能代表Cookie就没有任何用处，Cookie在Web编程中应用的几个方面： Cookie 的值能够持久化，即使客户端机器关闭，下次打开还是可以得到里面的值。因此 Cookie 可以用来减轻用户一些验证工作的输入负担，比如用户名和密码的输入，就可以在第一次登录成功之后，将用户名和密码保存在客户端 Cookie，下次不用输入。当然，这不安全，但是，对于一些安全要求不高的网站，Cookie 还是大有用武之地。 Cookie可以帮助服务器端保存多个状态信息，但是不用服务器端专门分配存储资源，减轻了服务器端的负担。比如网上商店中的购物车，必须将物品和具体客户名称绑定，但是放在服务器端又需要占据大量资源的情况下，可以用 Cookie 来实现，将每个物品和客户的内容作为 Cookie 来保存在客户端。 Cookie可以持久保持一些和客户相关的信息。如很多网站上，客户可以自主设计自己的个性化主页，其作用是避免用户每次都需要自己去找自己喜爱的内容，设计好之后，下次打开该网址，主页上显示的是客户设置好的界面。这些设置信息保存在服务器端的话，消耗服务器端的资源，因此，可以将客户的个性化设计保存在 Cookie 内，每一次访问该主页，客户端将 Cookie 发送给服务器端，服务器根据 Cookie 的值来决定显示给客户端什么样的界面。 解决Cookie安全问题 替代cookie。将数据保存在服务器端，可选的是session方案； 及时删除cookie，设置失效时间； Session方法 与前三种方法的区别 前几种方法在传递数据时，有一个共同的问题就是内容保存在客户端里。因此，具有泄露的危险性。如果在不考虑服务器负载的情况下，将数据保存在服务端里，是一个比较好的方法，这就是session方法。通过session.setAttribute(“num”,str);将str存到session中，通过session.getAttribute(“num”);从session中获取num 服务器如何知道要分配给它的是同一个 session 对象？ 在客户进行第一次访问时，服务器端就给 session 分配了一个 sessionId，并且让客户端记住了这个 sessionId，客户端访问下一个页面时，又将 sessionId 传送给服务器端，服务器端根据这个 sessionId 来找到前一个页面用的 session，由此保证为同一个客户服务的 session 对象是同一个。 session 分配的具体过程： 客户端访问服务器，服务器使用 session，首先检查这个客户端的请求里是否已包含了 sessionId； 如果有，服务器就在内存中检索相应 Id 的 session 来用； 否则服务器为该客户端创建一个 session 并且生成一个相应的 sessionId，并且在该次响应中返回给客户端保存。 session的应用session 经常用于保存用户登录状态。比如用户登录成功之后要访问好几个页面，但是每个页面都需要知道是哪个用户在登录，此时就可以将用户的用户名保存在 session 内。 session的不安全因素session 机制最大的不安全因素是 sessionId 可以被攻击者截获，如果攻击者通过一些手段知道了 sessionId，由于 sessionId 是客户端寻找服务器端 session 对象的唯一标识，攻击者就有可能根据 sesionId 来访问服务器端的 session 对象，得知 session 中的内容，从而实施攻击。 在 session 机制中，很多人认为：只要浏览器关闭，会话结束，session 就消失了。其实不然，浏览器关闭，会话结束，对于客户端来说，已经无法直接再访问原来的那个 session，但并不代表 session 在服务器端会马上消失。除非程序通知服务器删除一个 session，否则服务器会一直保留这个 session 对象，直到 session 超时失效，被垃圾收集机制收集掉。但是令人遗憾的是，客户在关闭浏览器时，一般不会通知服务器。由于关闭浏览器不会导致 session 被删除，因此，客户端关闭之后，session 还未失效的情况下，就给了攻击者以机会来获取 session 中的内容。 虽然 sessionId 是随机的长字符串，通常比较难被猜测到，这在某种程度上可以加强其安全性，但是一旦被攻击者获得，就可以进行一些攻击活动，如：攻击者获取客户 sessionId，然后攻击者自行伪造一个相同的 sessionId，访问服务器，实际上等价于伪装成该用户进行操作。 防止以上因为 sessionId 泄露而造成的安全问题 在服务器端，可以在客户端登陆系统时，尽量不要使用单一的 sessionId 对用户登陆进行验证。可以通过一定的手段，不时地变更用户的 sessionId； 在客户端，应该在浏览器关闭时删除服务器端的 session，也就是说在关闭时必须通知服务器端。可以用 Javascript 实现。","categories":[{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"https://jy3321.github.io/tags/JSP/"}],"author":"焦洋"},{"title":"Java面试题：调用try-catch-finally执行过程是怎样的","slug":"InterviewQuestion-TryCatch","date":"2019-09-02T10:09:21.000Z","updated":"2019-09-08T11:22:47.639Z","comments":true,"path":"2019/09/02/InterviewQuestion-TryCatch/","link":"","permalink":"https://jy3321.github.io/2019/09/02/InterviewQuestion-TryCatch/","excerpt":"","text":"问题1 调用下面的方法，得到的返回值是什么？ 12345678910111.public static int getNum() &#123;2. int a = 1;3. try &#123; 4. return a;5. &#125; catch (Exception e) &#123;6. System.out.println(\"11\");7. &#125; finally &#123;8. ++a;9. return a; 10. &#125; 11. &#125; 答案 返回 2 解析 代码正常执行try语句块中代码，并没有异常，所以不进入catch块，由于try结果是return语句，所以在返回前执行finally块中的语句，先将a自增，然后执行finally块语句中的return a，所以结果为 2 问题2 调用下面的方法，得到的返回值是什么？ 1234567891.public int getNum()&#123;2. try &#123;3. int a = 1/0;4. return 1;5. &#125; catch (Exception e) &#123;6. return 2;7. &#125;finally&#123;8. return 3;9.&#125; 答案 返回3 解析 代码在走到第 3 行的时候遇到了一个 MathException，这时第四行的代码就不会执行了，代码直接跳转到 catch语句中，走到第 6 行的时候，异常机制有这么一个原则：如果在 catch 中遇到了 return 或者异常等能使该函数终止的话，那么有 finally 就必须先执行完 finally 代码块里面的代码然后再返回值。因此代码又跳到第 8 行，可惜第 8 行是一个return 语句，那么这个时候方法就结束了，因此第 6 行的返回结果就无法被真正返回，而是执行了第8行的return 3，因此上面返回值是 3。 问题1 调用下面的方法，得到的返回值是什么？ 1234567891.public int getNum()&#123;2. try &#123;3. int a = 1/0;4. return 1;5. &#125; catch (Exception e) &#123;6. return 2;7. &#125;finally&#123;8. return 3;9.&#125; 答案 返回3 解析 代码在走到第 3 行的时候遇到了一个 MathException，这时第四行的代码就不会执行了，代码直接跳转到 catch语句中，走到第 6 行的时候，异常机制有这么一个原则：如果在 catch 中遇到了 return 或者异常等能使该函数终止的话，那么有 finally 就必须先执行完 finally 代码块里面的代码然后再返回值。因此代码又跳到第 8 行，可惜第 8 行是一个return 语句，那么这个时候方法就结束了，因此第 6 行的返回结果就无法被真正返回，而是执行了第8行的return 3，因此上面返回值是 3。","categories":[{"name":"Java面试题","slug":"Java面试题","permalink":"https://jy3321.github.io/categories/Java面试题/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"https://jy3321.github.io/tags/面试题/"}],"author":"焦洋"},{"title":"java面试题：对象被当参数传参后属性被改变并返回是传值还是传址","slug":"InterviewQuestion-byValueOrbyReference","date":"2019-09-02T08:23:07.000Z","updated":"2019-09-02T08:38:06.318Z","comments":true,"path":"2019/09/02/InterviewQuestion-byValueOrbyReference/","link":"","permalink":"https://jy3321.github.io/2019/09/02/InterviewQuestion-byValueOrbyReference/","excerpt":"","text":"题目 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? 答案 答：是值传递。Java编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用一个副本。指向同一个对象，对象的内容可以在被调用的方法中改变，但对象的引用(不是引用的副本)是永远不会改变的。 解析 Java中没有指针，所以也没有引用传递了，仅仅有值传递。不过，可以通过对象的方式来实现引用传递。类似java没有多继承，但可以用多次implements接口实现多继承的功能。 在Java应用程序中永远不会传递对象，而只传递对象的引用。因此是按引用传递对象。但重要的是要区分参数是如何传递的。 Java应用程序按引用传递对象这一事实并不意味着 Java 应用程序按引用传递参数。参数可以是对象引用，而 Java应用程序是按值传递对象引用的。 Java应用程序中的变量可以为以下两种类型之一：引用类型或基本类型。当作为参数传递给一个方法时，处理这两种类型的方式是相同的。两种类型都是按值传递的，没有一种按引用传递。 值传递：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中，对形式参数值的改变不影响实际参数的值。 引用传递：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的值。 按值传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的一个副本。因此，如果函数修改了该参数，仅改变副本，而原始值保持不变。 按引用传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的内存地址，而不是值的副本。因此，如果函数修改了该参数的值，调用代码中的原始值也随之改变。如果函数修改了该参数的地址，调用代码中的原始值不会改变。 示例代码 1234567891011121314151617// 在函数中传递的是基本数据类型public class Test &#123; public static void main(String[] args) &#123; int a = 3; int b = 4; change(a, b); System.out.println(\"a=\" + a); // 3 System.out.println(\"b=\" + b); // 4 &#125; public static void change(int i, int j) &#123; int temp = i; i = j; j = temp; &#125; &#125; 结果为:a=3b=4 原因：参数中传递的是基本数据类型a和b的拷贝，在函数中交换的也是那份拷贝的值，而不是数据本身。 123456789101112// 在函数中传的是引用数据类型 public class Test &#123; public static void main(String[] args) &#123; int[] count = &#123; 1, 2, 3, 4, 5 &#125;; change(count); // 6 &#125; public static void change(int[] counts) &#123; counts[0] = 6; System.out.println(counts[0]); &#125; &#125; 结果为：6 原因：在方法中，传递引用数据类型int数组，实际上传递的是该数组的地址值，他们都指向数组对象，在方法中可以改变数组对象的内容。 123456789101112131415161718传递的是对象的引用 class A &#123; int i = 0; &#125; public class Test &#123; public static void main(String args[]) &#123; A a = new A(); add(a); // 1 System.out.println(a.i); // 0 &#125; public static void add(A a) &#123; a = new A(); a.i++; System.out.println(a.i); &#125; &#125; 结果为：10 原因：在该程序中，对象的引用指向的是A，而在add方法中，传递的引用的一份副本则指向了一个新的对象，并对新的对象进行操作。而原来的A对象并没有发生任何变化。引用指向的是还是原来的A对象。 123456789101112131415161718// String 不改变，数组改变public class Example &#123; public static void main(String args[]) &#123; Example ex = new Example(); ex.change(ex.str, ex.ch); System.out.print(ex.str + \" and \"); // good and System.out.println(ex.ch); // gbc &#125; String str = new String(\"good\"); // good 是常量，不能改 char[] ch = &#123; 'a', 'b', 'c' &#125;; public void change(String str, char ch[]) &#123; str = \"test ok\"; // test ok 又是一个常量，也不能改 等价于 String str1 = new String(\"test ok\"); ch[0] = 'g'; &#125; &#125; 结果为：good and gbc 原因：String类比较特别，看过String类代码的都知道，String类是final修饰的。所以值是不变的。函数中String对象引用的副本指向了另外一个新String对象，而数组对象引用的副本没有改变，而是改变对象中数据的内容。对于对象类型，也就是Object的子类，如果你在方法中修改了它的成员的值，那个修改是生效的，方法调用结束后，它的成员是新的值；但是如果你把它指向一个其它的对象，方法调用结束后，原来对它的引用并没用指向新的对象。","categories":[{"name":"Java面试题","slug":"Java面试题","permalink":"https://jy3321.github.io/categories/Java面试题/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"https://jy3321.github.io/tags/面试题/"}],"author":"焦洋"},{"title":"算法题目：最长回文/另一个子树/拼写错误","slug":"AlgorithmicProblems","date":"2019-09-01T06:43:24.000Z","updated":"2021-10-20T03:20:00.834Z","comments":true,"path":"2019/09/01/AlgorithmicProblems/","link":"","permalink":"https://jy3321.github.io/2019/09/01/AlgorithmicProblems/","excerpt":"","text":"前言本文会将遇到的比较经典的算法题进行汇总，便于自己回忆学习，其中大部分题目和题解来自于 LeetCode（侵删）,会持续更新扩充。 5.最长回文子串 题目给定一个字符串 s，找到 s 中最长的回文子串。 解答回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n - 1个这样的中心。 你可能会问，为什么会是 2n - 1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如“abba” 的中心在两个‘b’ 之间）。所以中心点既有可能是一个字符，也有可能是两个字符，当中心为一个字符的时候有n个中心，当中心为两个字符的时候有n-1个中心，所以一共有2n-1个中心。 1234567891011121314151617181920212223public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) return \"\"; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1);&#125;private int expandAroundCenter(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1;&#125; 复杂度分析 时间复杂度：O(n^2)由于围绕中心来扩展回文会耗去 O(n)O(n) 的时间，所以总的复杂度为 O(n^2) 空间复杂度：O(1)。 其它更优方法 Manacher 算法还有一个复杂度为 O(n)O(n) 的 Manacher 算法，可以参考https://www.jianshu.com/p/116aa58b7d81 简单讲就是可以在字符串的每个字符前后各加一个不影响判断回文的字符，例如‘#‘,”aca“和”acca“，中心分别为’c‘和“cc“的中间，增添后的“#a#c#a#”，“#a#c#c#a#”，都为奇数长度的字符串，也就不会出现中心点在两个字符中间的情况。然后计算并通过回文半径进行判断。 572.另一个树的子树 题目给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 解答解决此题的思路非常简单，其实就是去比较s树每一个节点对应的子树是否和t相同，如果至少有一棵相同就返回true。 因此说白了就两步： 遍历s树。根据遍历结果，判断俩树是否相等。 1234567891011121314151617181920class Solution &#123; //遍历s树，去比较s树的每一个节点作为根节点对应的子树是否和t相等 public boolean isSubtree(TreeNode s, TreeNode t) &#123; if(s == null)&#123; return false; &#125; return isSame(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t); &#125; //判断s和t两棵树是否相等 private boolean isSame(TreeNode s, TreeNode t) &#123; if(s == null &amp;&amp; t == null)&#123; return true; &#125; if(s == null || t == null)&#123; return false; &#125; return s.val == t.val &amp;&amp; isSame(s.left, t.left) &amp;&amp; isSame(s.right, t.right); &#125;&#125; 总结在学习这道题的时候，理解了如何去做一道递归题目，在刚开始解决递归问题的时候，总是会去纠结这一层函数做了什么，它调用自身后的下一层函数又做了什么…然后就会觉得实现一个递归解法十分复杂，根本就无从下手。 相信很多刚开始做递归题的人都和我一样，这是一个思维误区，一定要走出来。既然递归是一个反复调用自身的过程，这就说明它每一级的功能都是一样的，因此我们只需要关注一级递归的解决过程即可。 递归时，我们应该这样想：递归应该在什么时候结束？（找整个递归的终止条件）应该给上一级返回什么信息？（找返回值）在一级递归中，应该完成什么任务？（本级递归应该做什么） 数组的相对排序 题目给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19] 提示 arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中 字节跳动笔试题：万万没想到之聪明的编辑 题目：我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径： 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -&gt; hello 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -&gt; hello 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC 我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！……万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的…… 请听题：请实现大锤的自动校对程序 方法一：正常思路实现功能 1234567891011121314151617181920212223242526272829303132333435public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); String[] strings = new String[N]; for (int i = 0; i &lt; N; i++) &#123; strings[i] = sc.next(); &#125; Solution1 solution = new Solution1(); for (String str : strings) System.out.println(solution.solve(str)); &#125;&#125;class Solution1 &#123; public String solve(String s) &#123; if (s == null || s.length() &lt;= 2) return s; for (int i = 0; i &lt; s.length() - 3; i++) &#123; if (s.charAt(i) == s.charAt(i + 1) &amp;&amp; s.charAt(i + 2) == s.charAt(i + 3)) &#123;//AABB s = delete(s, i + 2); i--; &#125; else if(s.charAt(i) == s.charAt(i + 1) &amp;&amp; s.charAt(i) == s.charAt(i + 2))&#123;//AAA s = delete(s,i); i--; &#125; &#125; int n = s.length(); if(s.charAt(n - 1) == s.charAt(n - 2) &amp;&amp; s.charAt(n - 1) == s.charAt(n - 3))//可能结尾剩余3个AAA的情况 s = delete(s,n-1); return s; &#125; private String delete(String s, int i) &#123; return s.substring(0, i) + s.substring(i + 1); &#125;&#125; 方法二：巧用转义字符 1234567891011import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int line = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i &lt; line; i++) &#123; System.out.println(scanner.nextLine().replaceAll(\"(.)\\\\1+\",\"$1$1\").replaceAll(\"(.)\\\\1(.)\\\\2\",\"$1$1$2\")); &#125; &#125;&#125; ### ### ###","categories":[{"name":"算法","slug":"算法","permalink":"https://jy3321.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://jy3321.github.io/tags/算法/"}],"author":"焦洋"},{"title":"计算机网络基础问题","slug":"ComputerNetwork","date":"2019-08-29T08:22:25.000Z","updated":"2019-08-29T09:24:51.620Z","comments":true,"path":"2019/08/29/ComputerNetwork/","link":"","permalink":"https://jy3321.github.io/2019/08/29/ComputerNetwork/","excerpt":"","text":"OSI与TCP/IP各层的结构与功能 五层协议的体系结构学习计算机网络时我们一般中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。 综合互联网情况，自上而下简要介绍一下各层的作用 1. 应用层应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。 域名系统 域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联 网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com 、 Oracle 公司的域名是 www.oracle.com 等。 HTTP协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。 2. 运输层运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。 运输层主要使用以下两种协议 传输控制协议 TCP（Transmisson Control Protocol）–提供面向连接的，可靠的数据传输服务。 用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。 UDP 的主要特点 UDP 是无连接的； UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）； UDP 是面向报文的； UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）； UDP 支持一对一、一对多、多对一和多对多的交互通信； UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。 TCP 的主要特点 TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）； 每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）； TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达； TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。 3. 网络层网络层(network layer)负责为分组交换网上的不同主机提供通信服务。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用IP 协议，因此分组也叫IP 数据报 ，简称 数据报。 这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。 网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分株，能通过网络层中的路由器找到目的主机。 这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称. 互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。 4. 数据链路层数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。 5. 物理层物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 在物理层上所传送的数据单位是比特。 在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。 体系结构图 图片来源及OSI相关知识点参考博客 ：https://blog.csdn.net/yaopeng_2005/article/details/7064869 TCP 三次握手和四次挥手 图解为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。三次握手： 图片来源：《图解HTTP》 客户端–发送带有 SYN 标志的数据包–一次握手–服务端 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端 四次挥手 断开一个 TCP 连接则需要“四次挥手” 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号 服务器-关闭与客户端的连接，发送一个FIN给客户端 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1 为什么要三次握手三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。 为什么要四次挥手任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。 推荐参考一篇讲的比较细致的文章：https://blog.csdn.net/qzcsu/article/details/72861891 为什么要传回 SYN接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。 传了 SYN,为什么还要传 ACK双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。 TCP、UDP 协议的区别 UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。 TCP 协议如何保证可靠传输 应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 停止等待协议 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 停止等待协议停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认； 1) 无差错情况: 发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。 2) 出现差错情况（超时重传）: 停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。 3) 确认丢失和确认迟到 确认丢失：确认消息在传输过程丢失 当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施： 丢弃这个重复的M1消息，不向上层交付。 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。 确认迟到 ：确认消息在传输过程中迟到 A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下： 1. A收到重复的确认后，直接丢弃。 2. B收到重复的M1后，也直接丢弃重复的M1。连续ARQ协议连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。 优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。 缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。 滑动窗口 TCP 利用滑动窗口实现流量控制的机制。 滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。 TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。 流量控制 TCP 利用滑动窗口实现流量控制。 流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 拥塞控制在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd)的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。 TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。 慢开始 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。 拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1. 快重传与快恢复：在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程 状态码 各种协议与HTTP协议之间的关系 图片来源：《图解HTTP》 HTTP长连接、短连接 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。参考文章：https://www.cnblogs.com/gotodsp/p/6366163.html 总结 问题： TCP三次握手和四次挥手、 在浏览器中输入url地址-&gt;&gt;显示主页的过程 HTTP和HTTPS的区别 TCP、UDP协议的区别 常见的状态码。 参考了大量网上的资料及回答，部分引用内容下有参考博客的连接，文中大部分的图片来自于《图解HTTP》 。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://jy3321.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://jy3321.github.io/tags/计算机网络/"}],"author":"焦洋"},{"title":"Java中@Override的作用","slug":"Override","date":"2019-08-23T06:01:21.000Z","updated":"2019-08-23T06:31:13.418Z","comments":true,"path":"2019/08/23/Override/","link":"","permalink":"https://jy3321.github.io/2019/08/23/Override/","excerpt":"","text":"@Override是伪代码,表示重写，在java代码编写时经常会看到，写上它有如下好处: 可以当注释用,方便阅读； 编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。如果你在继承父类没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。 举例：在重写父类的onCreate时，在方法前面加上@Override 系统可以帮你检查方法的正确性。 @Override public void onCreate(Bundle savedInstanceState){ …… }这种写法是正确的，如果你写成： @Override public void oncreate(Bundle savedInstanceState){ …… }编译器会报如下错误：The method oncreate(Bundle) of type HelloWorld must override or implement a supertype method，以确保你正确重写onCreate方法（因为oncreate应该为onCreate）。而如果你不加@Override，则编译器将不会检测出错误，而是会认为你为子类定义了一个叫oncreate的新方法。","categories":[{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/tags/Java/"}],"author":"焦洋"},{"title":"Java多线程问题合集","slug":"Multithreading","date":"2019-08-22T12:52:53.000Z","updated":"2019-08-23T06:29:51.663Z","comments":true,"path":"2019/08/22/Multithreading/","link":"","permalink":"https://jy3321.github.io/2019/08/22/Multithreading/","excerpt":"","text":"参考了网上关于多线程的题目，将题目汇总如下，便于自己记忆 1、多线程有什么用？ 一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法： （1）发挥多核CPU的优势 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。 （2）防止阻塞 从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。 （3）便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 2、创建线程的方式 比较常见的一个问题了，一般就是两种： （1）继承Thread类 （2）实现Runnable接口 至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。 3、start()方法和run()方法的区别 只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。 4、Runnable接口和Callable接口的区别 有点深的问题了，也看出一个Java程序员学习知识的广度。 Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。 5、CyclicBarrier和CountDownLatch的区别 两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于： （1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行 （2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务 （3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了 6、volatile关键字的作用 一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个： （1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据 （2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率 从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。 7、什么是线程安全 又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 这个问题有值得一提的地方，就是线程安全也是有几个级别的： （1）不可变 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 （2）绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet （3）相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。 （4）线程非安全 这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类 8、Java中如何获取到线程dump文件 死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步： （1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java （2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid 另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈， 9、一个线程如果出现了运行时异常会怎么样 如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放 10、如何在两个线程之间共享数据 通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的 11、sleep方法和wait方法有什么区别 这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器 12、生产者消费者模型的作用是什么 这个问题很理论，但是很重要： （1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用 （2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约 13、ThreadLocal有什么用 简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了 14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用 这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁 15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别 wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。 16、为什么要使用线程池 避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。 17、怎么检测一个线程是否持有对象监视器 我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。 18、synchronized和ReentrantLock的区别 synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： （1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 （2）ReentrantLock可以获取各种锁的信息 （3）ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。 19、ConcurrentHashMap的并发度是什么 ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？ 20、ReadWriteLock是什么 首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。 因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 21、FutureTask是什么 这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。 22、Linux环境下如何查找哪个线程使用CPU最长 这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做： （1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过 （2）top -H -p pid，顺序不能改变 这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。 使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。 最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。 23、Java编程写一个会导致死锁的程序 第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。 真正理解什么是死锁，这个问题其实不难，几个步骤： （1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁； （2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁 （3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的 这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。 24、怎么唤醒一个阻塞的线程 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 25、不可变对象对多线程有什么帮助 前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。 26、什么是多线程的上下文切换 多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。 27、如果你提交任务时，线程池队列已满，这时会发生什么 这里区分一下： 如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务 如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy 28、Java中用到的线程调度算法是什么 抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 29、Thread.sleep(0)的作用是什么 这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。 30、什么是自旋 很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 31、什么是Java内存模型 Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容： （1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去 （2）定义了几个原子操作，用于操作主内存和工作内存中的变量 （3）定义了volatile变量的使用规则 （4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的 32、什么是CAS CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。 33、什么是乐观锁和悲观锁 （1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 （2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。 34、什么是AQS 简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。 如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。 AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。 35、单例模式的线程安全性 老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下： （1）饿汉式单例模式的写法：线程安全 （2）懒汉式单例模式的写法：非线程安全 （3）双检锁单例模式的写法：线程安全 36、Semaphore有什么作用 Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。 37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？ 这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？ 关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点： （1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性 （2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。 38、线程类的构造方法、静态块是被哪个线程调用的 这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。 如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么： （1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的 （2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的 39、同步方法和同步块，哪个是更好的选择 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。 借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。 40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？ 这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是： （1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换 （2）并发不高、任务执行时间长的业务要区分开看： a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换 （3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。","categories":[{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://jy3321.github.io/tags/多线程/"}],"author":"焦洋"},{"title":"Java内存机制及堆和栈的区别","slug":"StackAndHeap","date":"2019-08-18T08:42:22.000Z","updated":"2019-08-22T04:02:36.317Z","comments":true,"path":"2019/08/18/StackAndHeap/","link":"","permalink":"https://jy3321.github.io/2019/08/18/StackAndHeap/","excerpt":"","text":"​ 几个计算机基础概念 计算机存储单位 从小到大依次为位Bit、字节Byte、千字节KB、兆M、千兆GB、TB，相邻单位之间都是1024倍，1024为2的10次方，即： 1Byte = 8bit 1K = 1024Byte 1M = 1024K 1G = 1024M 1T = 1024G 计算机存储元件 寄存器：中央处理器CPU的一部分，是计算机中读写速度最快的存储元件，但是容量很少 内存：属于独立的一个部件，是和CPU沟通的桥梁，用于存放CPU中的运算数据以及与外部存储器交换的数据。尽管在今天，对内存的读写速度已经很快了，但是由于寄存器是在CPU上的，所以对于内存的读写速度和对于寄存器的读写速度上还是有几个数量级的差距。但是没办法，对于内存的读写I/O操作是很难消除的，寄存器数量有限，不可能通过寄存器来完成所有的运算任务 内核空间和用户空间 连接内存和寄存器的是地址总线，地址总线的宽度影响了物理地址的索引范围，因为总线宽度决定了处理器一次可以从寄存器或内存中获取多少个Bit，同时也决定了处理器最大可以寻址的地址空间。比如32位CPU的系统，可寻址范围为0x00000000~0xFFFFFFFF，即232=4294967296个内存位置，每个内存位置1个字节，即32位CPU系统可以有4GB的内存空间。不过应用程序是不可以完全使用这些地址空间的，因为这些地址空间被划分为了内核空间和用户空间，程序只能使用用户空间的内存。内核空间主要是指操作系统运行时所使用的用于程序调度、虚拟内存的使用或者链接硬件资源的程序逻辑。区分内核空间和用户空间的目的主要是从系统的稳定性的角度考虑的。Windows 32操作系统默认内核空间和用户空间的比例是1:1，即2G内核空间、2G内存空间，32位Linux系统中默认比例则是1:3，即1G内核空间，3G内存空间。 字长 CPU的主要技术指标之一，指的是CPU一次能并行处理二进制的位数（Bit）。通常称处理字长为8位数据的CPU为8位CPU，32位CPU就是在同一时间内处理字长为32位的二进制数据。不过目前虽然CPU大多是64位的，但还是以32位字长运行。 Java内存机制 内存区域Java虚拟机（JVM）内部定义了程序在运行时需要使用到的内存区域。 之所以要划分这么多区域出来是因为这些区域都有自己的用途，以及创建和销毁的时间。 有些区域随着虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而销毁和建立。 图中绿色部分就是所有线程之间共享的内存区域，而白色部分则是线程运行时独有的数据区域，从这个分类角度来看一下这几个数据区。 线程独有的内存区域PROGRAM COUNTER REGISTER，程序计数器程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 JAVA STACK，虚拟机栈 与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。 虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 NATIVE METHOD STACK，本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError异常和OutOfMemoryError异常。 线程间共享的内存区域HEAP，堆 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。 如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。 如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。 不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 METHOD AREA，方法区 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。 Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 RUNTIME CONSTANT POOL，运行时常量池 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 创建对象Java是一门面向对象的语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象（克隆、反序列化）就是一个new关键字而已，但是虚拟机层面上却不是如此。看一下在虚拟机层面上创建对象的步骤： 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有，那么必须先执行类的初始化过程。 类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存大小在类加载完成后便可以完全确定，为对象分配空间无非就是从Java堆中划分出一块确定大小的内存而已。这个地方会有两个问题： （1）如果内存是规整的，那么虚拟机将采用的是指针碰撞法来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。 （2）如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。 另外一个问题及时保证new对象时候的线程安全性。因为可能出现虚拟机正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。虚拟机采用了CAS（Compare-and-Swap，即比较并替换，是一种实现并发算法时常用到的技术）配上失败重试的方式保证更新更新操作的原子性和TLAB（Thread Local Allocation Buffer，划分出多个线程私有的分配缓冲区）两种方式来解决这个问题。 内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。 对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。 执行 init 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 访问对象对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、ava堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码： 1 Object obj = new Object(); 假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而“new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。 由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。 如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。 如果使用的是直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址。 这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。 看一个例子 问题一： String str1 = &quot;abc&quot;; String str2 = &quot;abc&quot;; System.out.println(str1==str2); //true问题二： String str1 =new String (&quot;abc&quot;); String str2 =new String (&quot;abc&quot;); System.out.println(str1==str2); // false问题三: String s1 = &quot;ja&quot;; String s2 = &quot;va&quot;; String s3 = &quot;java&quot;; String s4 = s1 + s2; System.out.println(s3 == s4);//false System.out.println(s3.equals(s4));//true在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 堆内存用来存放由new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 具体的说栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new 、newarray 、anewarray 和multianewarray 等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。 栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义： int a = 3; int b = 3； 编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。 String是一个特殊的包装类数据。可以用： String str = new String(“abc”); String str = “abc”; 两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。 而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放”abc”，如果没有，则将”abc”存放进栈，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。比较类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用== 下面用例子说明上面的理论。 方式一： String str1 = &quot;abc&quot;; String str2 = &quot;abc&quot;; System.out.println(str1==str2); //true可以看出str1和str2是指向同一个对象的。 方式二： String str1 =new String (&quot;abc&quot;); String str2 =new String (&quot;abc&quot;); System.out.println(str1==str2); // false用new的方式是生成不同的对象。每一次生成一个。 因此用第一种方式创建多个”abc”字符串,在内存中其实只存在一个对象而已. 这种写法有利与节省内存空间. 同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(“abc”)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。 另一方面, 要注意: 我们在使用诸如String str = “abc”；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的对象。只有通过new()方法才能保证每次都创建一个新的对象。由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。 栈的概念 堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，队列优先,先进先出（FIFO—first in first out）。栈，先进后出(FILO—First-In/Last-Out)。 主要区别 一、空间分配 1.堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表。PS：java中都是系统GC，程序员无法进行GC。2.栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量值等。操作方式与数据结构中的栈相类似。 二、缓存方式 1.堆：使用二级缓存，生命周期与虚拟机的GC算法有关（并不是引用为空就立即被GC），调用速度相对较低。2.栈：使用一级缓存，被调用时通常处于存储空间中，调用后被立即释放。 三、数据结构 1、堆（数据结构）：类似于树结构，可以类比于堆排序2、栈（数据结构）：先进后出（FILO） JAVA中的区别 堆（heap）与栈（stack）都是java在RAM中用来存放数据的地方。与C++不同的是，java自动管理堆（heap）和（栈），程序员不能直接的设置堆和栈。 栈：在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被用作他用。 堆：对内存用来存放由new创建的对象和数组，在堆中分配的内存，由java虚拟机的自动垃圾回收器来管理。在堆中产生一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。 Java中变量在内存中的分配 1.类变量（static修饰的变量，静态变量）：在程序加载时系统就为他在队中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期——一直到系统关闭。 2.实例变量（实例化对象）：当你使用java关键字new时，系统在堆中开辟并不一定是连续的空间分配给变量，然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的“物理位置”。实例变量的生命周期——实例变量的引用丢失后，将被GC列入到可回收名单中，但不是马上回收释放。 3.局部变量：生命在某个方法或者某段代码里面，执行到他的时候在栈中开辟内存，局部变量一旦脱离作用域，内存立即释放。 参考部分内容参考以下博客： https://www.cnblogs.com/xrq730/p/4827590.html https://www.cnblogs.com/gw811/p/2730117.html","categories":[{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/categories/Java/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://jy3321.github.io/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/tags/Java/"},{"name":"Stack","slug":"Stack","permalink":"https://jy3321.github.io/tags/Stack/"},{"name":"Heap","slug":"Heap","permalink":"https://jy3321.github.io/tags/Heap/"}],"author":"焦洋"},{"title":"HTTP和HTTPS协议分别是什么","slug":"http-https","date":"2019-08-16T07:49:03.000Z","updated":"2019-08-22T02:51:00.657Z","comments":true,"path":"2019/08/16/http-https/","link":"","permalink":"https://jy3321.github.io/2019/08/16/http-https/","excerpt":"","text":"一、什么是协议？ (网络)协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信。 二、HTTP协议是什么？ HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 HTPP有多个版本，目前广泛使用的是HTTP/1.1版本。 三、HTTP原理 HTTP是一个基于TCP/IP通信协议来传递数据的协议，传输的数据类型为HTML 文件,、图片文件, 查询结果等。 HTTP协议一般用于B/S架构（）。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 以访问百度：www.baidu.com 为例： 客户端 将 www.baidu.com DNS域名解析为服务器IP 客户端 发起TCP请求，3次握手建立连接 客户端发出HTTP请求 服务器端 进行HTTP响应 客户端将响应得到的HTML代码和资源值渲染到前端给用户 四、HTTP特点 http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。 灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。 无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie ,一个叫做Session。 无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。 五、URI和URL的区别 HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 URI：Uniform Resource Identifier 统一资源标识符 URL：Uniform Resource Location 统一资源定位符 URI 是用来标示 一个具体的资源的，我们可以通过 URI 知道一个资源是什么。 URL 则是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。 六、HTTP报文组成 请求报文构成 请求行：包括请求方法、URL、协议/版本 请求头(Request Header) 请求正文 响应报文构成 状态行 响应头 响应正文 七、常见请求方法 (网络)协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“GET:请求指定的页面信息，并返回实体主体。 POST:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 HEAD:类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 PUT:从客户端向服务器传送的数据取代指定的文档的内容。 DELETE:请求服务器删除指定的页面。，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信。 post和get的区别： 都包含请求头请求行，post多了请求body。 get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。 GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。 GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。 八、响应状态码 访问一个网页时，浏览器会向web服务器发出请求。此网页所在的服务器会返回一个包含HTTP状态码的信息头用以响应浏览器的请求。 状态码分类： 1XX- 信息型，服务器收到请求，需要请求者继续操作。 2XX- 成功型，请求成功收到，理解并处理。 3XX - 重定向，需要进一步的操作以完成请求。 4XX - 客户端错误，请求包含语法错误或无法完成请求。 5XX - 服务器错误，服务器在处理请求的过程中发生了错误。 常见状态码： 200 OK - 客户端请求成功 301 - 资源（网页等）被永久转移到其它URL 302 - 临时跳转 400 Bad Request - 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 404 - 请求资源不存在，可能是输入了错误的URL 500 - 服务器内部发生了不可预期的错误 503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。 九、为什么要用HTTPS？ 实际使用中，绝大说的网站现在都采用的是https协议，这也是未来互联网发展的趋势。因为当使用HTTP协议传输一些内容的时候，比如登录过程，访问的账号密码都是明文传输， 这样客户端发出的请求很容易被不法分子截取利用，因此，HTTP协议不适合传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信息非常不安全。 一般http中存在如下问题： 请求信息明文传输，容易被窃听截取。 数据的完整性未校验，容易被篡改 没有验证对方身份，存在冒充危险 十、什么是HTTPS? 为了解决上述HTTP存在的问题，就用到了HTTPS。 HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。 那么SSL又是什么？ SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。 TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。 SSL发展史（互联网加密通信） 1994年NetSpace公司设计SSL协议（Secure Sockets Layout）1.0版本，但未发布。 1995年NetSpace发布SSL/2.0版本，很快发现有严重漏洞 1996年发布SSL/3.0版本，得到大规模应用 1999年，发布了SSL升级版TLS/1.0版本，目前应用最广泛的版本 2006年和2008年，发布了TLS/1.1版本和TLS/1.2版本 十、什么是HTTPS? (网络)协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信。 十一、浏览器在使用HTTPS传输数据的流程是什么？ 首先客户端通过URL访问服务器建立SSL连接。 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 服务器利用自己的私钥解密出会话密钥。 服务器利用会话密钥加密与客户端之间的通信。 十二、HTTPS的缺点 HTTPS协议多次握手，导致页面的加载时间延长近50%； HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗； 申请SSL证书需要钱，功能越强大的证书费用越高。 SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。 十三、总结HTTPS和HTTP的区别 HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。 http和https使用连接方式不同，默认端口也不一样，http是80，https是443。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://jy3321.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://jy3321.github.io/tags/计算机网络/"},{"name":"HTTP","slug":"HTTP","permalink":"https://jy3321.github.io/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://jy3321.github.io/tags/HTTPS/"}],"author":"焦洋"},{"title":"Hexo博客Indigo主题安装","slug":"HexoThemes","date":"2019-08-13T13:31:44.000Z","updated":"2019-08-14T06:57:14.902Z","comments":true,"path":"2019/08/13/HexoThemes/","link":"","permalink":"https://jy3321.github.io/2019/08/13/HexoThemes/","excerpt":"","text":"写在前面 在之前的博客文章中我们已经搭建了Github+Hexo博客，如果不知道如何搭建，可以参考 Hexo博客搭建 。当我们初步搭建完成自己的个人博客之后，会发现它的默认主题不是很美观，可以在 hexo官方主题 可以看到有很多不错的主题，我们选择自己喜欢的来美化自己的博客。在这里推荐我个人比较喜欢的有 miho 、indigo ，这两个主题都是我自己用过的，现在自己使用的主题是 indigo ,下面也是用这个主题作为教程。 主题安装 安装需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上。我们可以在 indigo 的主页上获取到它的https地址： 在 Hexo 根目录，执行以下命令： 1git clone https://github.com/yscoder/hexo-theme-indigo.git themes/indigo 这个命令要在博客文件夹的根目录右击鼠标打开Git Bash输入命令，其中themes/indigo就是会在博客文件夹根目录中的themes新建一个indigo文件夹存放clone下来的主题，以后indigo主题相关的东西都是存放在这个目录下。 简单讲这个命令就是 git clone +主题在github中的https +themes/indig 依赖安装 安装Less主题默认使用 less 作为 css 预处理工具。 1npm install hexo-renderer-less --save 安装Feed用于生成 rss 1npm install hexo-generator-feed --save 安装Json-content用于生成静态站点数据，用作站内搜索的数据源。这个在博客刚开始搭建安装依赖的时候，大部分都安装了。 1npm install hexo-generator-json-content --save 安装QRCode用于生成微信分享二维码。网页分享中微信可以动态生成该网页的分享分二维码。 1npm install hexo-helper-qrcode --save Hexo新建文件 新建一篇文章进行测试 1hexo new \"PageName\" 开启标签页 开启标签页，会新建一个名为tags文件夹，文件夹有一个index.md文件。 1hexo new page tags 修改 hexo/source/tags/index.md 的元数据 123layout: tags comments: false --- 开启分类页 同样的开启分类页，也会新建一个名为categories的文件夹，文件夹有一个index.md文件。 1hexo new page categories 修改 hexo/source/categories/index.md 123layout: categories comments: false --- 修改完之后的目录应该如图： 切换主题 启用主题在你博客的根目录下找到_config.yml 文件，将其中的 theme 属性改为 indigo : 文件清理清理之前在public文件夹中生成的文件 1hexo clean 生成静态文件在public文件夹中生成html、css、xml等前台静态文件。 1hexo g 开启本地服务你就可以在http://localhost:4000/中预览 1hexo s 上传到github1hexo d 到此， hexo 博客的 indigo 主题就安装完毕了。类似的，你也可以去尝试安装其它的主题。安装方法都是将主题克隆到自己的 themes 文件夹下，然后安装相应的依赖，配置并启用主题就可以了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://jy3321.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://jy3321.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://jy3321.github.io/tags/GitHub/"},{"name":"Indigo","slug":"Indigo","permalink":"https://jy3321.github.io/tags/Indigo/"}],"author":"焦洋"},{"title":"Hexo博客如何添加评论功能","slug":"HexoComments","date":"2019-08-11T16:00:00.000Z","updated":"2019-08-14T05:18:59.701Z","comments":true,"path":"2019/08/12/HexoComments/","link":"","permalink":"https://jy3321.github.io/2019/08/12/HexoComments/","excerpt":"","text":"写在前面想要让自己的博客能够进行互动，所以要添加评论功能。自己也是捣鼓了一会才终于实现。 评论系统的选择 多说：貌似已经关闭了 disqus：需要翻墙访问才行 友言:不支持https协议，而github使用的是https协议 网易云跟帖：需要域名 搜狐畅言：需要备案，不然只能使用15天 来比力：很多人都推荐使用这个，自己尝试了下确实可行。但是加载速度是真的是太慢了。。。 在GG了一堆评论系统后，最后发现了一个叫 valine 的评论系统， indigo主题其实也配置了这个系统。 Valine评论系统安装 首先我们要去 leancloud 官网注册一个账号，由于国内版的最近好像也要GG，所以我们选择注册 国际版Valine ,注册成功之后创建一个应用，选择开发版即可，在应用Key中我们可以看到你的 AppID 和 AppKey 打开主题文件夹中的配置文件 _config.yml ，填写其中的valine，例如我的： 最后，在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去。 然后你的评论系统应该就可以用了。以上是针对例如 indigo 等自带 valine 配置文件的博客主题的安装方法。如果你的博客主题中没有 valine，你也可以去 Valine官网 阅读以下文档进行相关配置，只需要添加几行代码，操作起来也是很简单的。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://jy3321.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://jy3321.github.io/tags/Hexo/"},{"name":"Valine","slug":"Valine","permalink":"https://jy3321.github.io/tags/Valine/"}],"author":"焦洋"},{"title":"Hexo博客插入图片的问题","slug":"HexoPictures","date":"2019-08-11T16:00:00.000Z","updated":"2019-08-13T13:30:40.353Z","comments":true,"path":"2019/08/12/HexoPictures/","link":"","permalink":"https://jy3321.github.io/2019/08/12/HexoPictures/","excerpt":"","text":"Hexo博客插入图片在编写自己博客的时候肯定要加入图片方便理解。但是当我把图片加入文章（直接复制进文章的时候），他的提示是这样的: 图片的插入格式是 ！[]() ，其中[ ]内是图片的标题，一般为图片名，也可以不填，() 里是图片的地址。当我们这样插入图片的时候，我们是可以在自己的文章中看到的，但是上传github后发现在网页上并不能看到。就是这个路径的问题。关于插入图片的路径，有两种方式。 绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。对于source/images/image.jpg这张图片可以用以下语法访问到 1![](/images/image.jpg) 这样填写路径的图片，既可以在首页内容中访问到，也可以在文章正文中访问到。我的博客的首页背景，文章首页的图片，用的都是这个路径。 相对路径图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置博客根目录下的_config.yml来生成。 1.将_config.yml文件中的配置项post_asset_folder设为true后 img 2.打开Git Bash，下载一个插件（需要等待一阵..） 1npm install https://github.com/CodeFalling/hexo-asset-image --save 3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。 然后你在写文章的时候，关于这篇文章的图片，就可以放在这个相同名字的文件夹中。比如你在文件夹中存了一张名为image.jpg的图片，你就可以直接使用markdown的引用进行使用。 1![](image.jpg) 这样填写路径的图片，只能在文章中显示，无法在首页中正常显示，但是其实对于文章中的图片，就已经可以了。如果你想要图片在文章和首页中同时显示，可以使用标签插件语法。_posts/post_name/image.jpg这张照片可以用以下方式访问： 1&#123;% asset_img image.jpg This is an image %&#125; 总结简而言之，就是在你使用hexo n新建一篇文章的时候，会自动在你文章的同一目录下新建一个与文章名相同名字的文件夹，你可以把这篇文章的相关图片都放在这个文件夹下，然后用![](image.jpg)的方式引用它。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://jy3321.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://jy3321.github.io/tags/Hexo/"}],"author":"焦洋"},{"title":"Windows下如何查看某个端口被谁占用","slug":"PortOccupancy","date":"2019-08-11T16:00:00.000Z","updated":"2019-08-12T07:16:29.347Z","comments":true,"path":"2019/08/12/PortOccupancy/","link":"","permalink":"https://jy3321.github.io/2019/08/12/PortOccupancy/","excerpt":"","text":"我们以4000端口为例： 1.按下 Win+R 再输 入cmd 调出命令行窗口，输入 netstat -aon|findstr &quot;4000&quot; ，找到指定行最后一列的数字 （PID） ，我们这里是 8364 .2.输入 tasklist|findstr &quot;8364&quot; ，发现是 node.exe 占用了4000端口。3.再次输入 taskkill /f /t /im node.exe 结束该进程。 QQ图片20190812141332 当然第二第三步你也可以再任务管理中进行操作，只需要第一步 netstat -aon|findstr &quot;4000&quot; 找到PID，在任务管理器中PID一列找到对应的进程并把它结束就可以了。如果任务管理器中没有PID这一列，右键单击列头，勾选PID这一列就可以看到了。","categories":[{"name":"Windows","slug":"Windows","permalink":"https://jy3321.github.io/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://jy3321.github.io/tags/Windows/"}],"author":"焦洋"},{"title":"数据结构基础知识总结","slug":"DataStructure","date":"2019-07-31T16:00:00.000Z","updated":"2019-09-06T02:37:37.414Z","comments":true,"path":"2019/08/01/DataStructure/","link":"","permalink":"https://jy3321.github.io/2019/08/01/DataStructure/","excerpt":"","text":"相关基础概念 数据结构就是研究数据的逻辑结构和物理结构以及它们之间相互关系，并对这种结构定义相应的运算，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型. 数据：所有能被输入到计算机中，且能被计算机处理的符号的集合。是计算机操作的对象的总称。 数据元素：数据（集合）中的一个“个体”，数据及结构中讨论的基本单位 数据项：数据的不可分割的最小单位。一个数据元素可由若干个数据项组成。 数据类型：在一种程序设计语言中，变量所具有的数据种类。整型、浮点型、字符型等等。 逻辑结构：数据之间的相互关系。 集合 结构中的数据元素除了同属于一种类型外，别无其它关系。 线性结构 数据元素之间一对一的关系 树形结构 数据元素之间一对多的关系 图状结构或网状结构 结构中的数据元素之间存在多对多的关系 物理结构/存储结构：数据在计算机中的表示。物理结构是描述数据具体在内存中的存储（如：顺序结构、链式结构、索引结构、哈希结构）等。 在数据结构中,从逻辑上可以将其分为线性结构和非线性结构。 数据结构的基本操作的设置的最重要的准则是实现应用程序与存储结构的独立。实现应用程序是“逻辑结构”，存储的是“物理结构”。逻辑结构主要是对该结构操作的设定，物理结构是描述数据具体在内存中的存储（如：顺序结构、链式结构、索引结构、希哈结构）等。 顺序存储结构中，线性表的逻辑顺序和物理顺序总是一致的。但在链式存储结构中，线性表的逻辑顺序和物理顺序一般是不同的。 算法五个特性： 有穷性、确定性、可行性、输入、输出。 算法设计要求：正确性、可读性、健壮性、高效率与低存储量需求。(好的算法) 算法的描述有伪程序、流程图、N-S结构图等。E-R图是实体联系模型，不是程序的描述方式。 设计算法在执行时间时需要考虑：算法选用的规模、问题的规模。 时间复杂度：算法的执行时间与原操作执行次数之和成正比。时间复杂度有小到大：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)、O(n3)。幂次时间复杂度有小到大O(2n)、O(n!)、O(nn)。 空间复杂度：若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的辅助变量所占额外空间。 线性表 线性表是一种典型的线性结构。头结点无前驱有一个后继，尾节点无后继有一个前驱。链表只能顺序查找，定位一个元素的时间为O(N)，删除一个元素的时间为O(1)。 线性表的顺序存储结构：把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里。用这种方法存储的线性表简称顺序表。是一种随机存取的存储结构。顺序存储指内存地址是一块的，随机存取指访问时可以按下标随机访问，存储和存取是不一样的。如果是存储，则是指按顺序的，如果是存取，则是可以随机的，可以利用元素下标进行。数组比线性表速度更快的是：原地逆序、返回中间节点、选择随机节点。 便于线性表的构造和任意元素的访问 插入：插入新结点，之后结点后移。平均时间复杂度:O(n) 删除：删除节点，之后结点前移。平均时间复杂度:O(n) 线性链表：用一组任意的存储单元来依次存放线性表的结点，这组存储单元即可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上的。因此，链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址。data域是数据域，用来存放结点的值。next是指针域（亦称链域），用来存放结点的直接后继的地址（或位置）。不需要事先估计存储空间大小。 单链表 中每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，故应设头指针head指向开始结点。同时，由于最后一个结点无后继，故结点的指针域为空，即NULL。头插法建表(逆序)、尾插法建表(顺序)。增加头结点的目的是算法实现上的方便，但增大了内存开销。 查找：只能从链表的头指针出发，顺链域next逐个结点往下搜索，直到搜索到第i个结点为止。因此，链表不是随机存取结构。 插入：先找到表的第i-1的存储位置，然后插入。新结点先连后继，再连前驱。 删除：首先找到ai-1的存储位置p。然后令p–&gt;next指向ai的直接后继结点，即把ai从链上摘下。最后释放结点ai的空间.r=p-&gt;next;p-&gt;next=r-&gt;next;delete r。 判断一个单向链表中是否存在环的最佳方法是快慢指针。 静态链表：用一维数组来实现线性链表，这种用一维数组表示的线性链表，称为静态链表。静态：体现在表的容量是一定的。（数组的大小）；链表：插入与删除同前面所述的动态链表方法相同。静态链表中指针表示的是下一元素在数组中的位置。 静态链表是用数组实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配大小。动态链表是用申请内存函数（C是malloc,C++是new）动态申请内存的，所以在链表的长度上没有限制。动态链表因为是动态申请内存的，所以每个节点的物理地址不连续，要通过指针来顺序访问。静态链表在插入、删除时也是通过修改指针域来实现的，与动态链表没有什么分别 循环链表：是一种头尾相接的链表。其特点是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活。 在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为单循环链表。由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p—&gt;next是否为空，而是判断它们是否等于某一指定指针，如头指针或尾指针等。 双向链表:在单链表的每个结点里再增加一个指向其直接前趋的指针域prior。这样就形成的链表中有两个方向不同的链。双链表一般由头指针唯一确定的，将头结点和尾结点链接起来构成循环链表，并称之为双向链表。设指针p指向某一结点，则双向链表结构的对称性可用下式描述：p—&gt;prior—&gt;next=p=p—&gt;next—&gt;prior。从两个方向搜索双链表，比从一个方向搜索双链表的方差要小。 插入：先搞定插入节点的前驱和后继，再搞定后结点的前驱，最后搞定前结点的后继。 在有序双向链表中定位删除一个元素的平均时间复杂度为O(n) 可以直接删除当前指针所指向的节点。而不需要像单向链表中，删除一个元素必须找到其前驱。因此在插入数据时，单向链表和双向链表操作复杂度相同，而删除数据时，双向链表的性能优于单向链表 栈和队列 栈栈(Stack)是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(Top)，另一端为栈底(Bottom)。先进后出。top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增。 顺序存储栈：顺序存储结构 链栈：链式存储结构。插入和删除操作仅限制在链头位置上进行。栈顶指针就是链表的头指针。通常不会出现栈满的情况。 不需要判断栈满但需要判断栈空。 两个栈共用静态存储空间,对头使用也存在空间溢出问题。栈1的底在v[1]，栈2的底在V[m]，则栈满的条件是top[1]+1=top[2]。 基本操作：删除栈顶元素、判断栈是否为空以及将栈置为空栈等 对于n各元素的入栈问题，可能的出栈顺序有C(2n,n)/(n+1)个。 堆栈溢出一般是循环的递归调用、大数据结构的局部变量导致的应用： 进制转换 括号匹配的检验 行编辑程序 迷宫求解：若当前位置“可通”，则纳入路径，继续前进;若当前位置“不可通”，则后退，换方向继续探索;若四周“均无通路”，则将当前位置从路径中删除出去。 表达式求解：前缀、中缀、后缀。 操作数之间的相对次序不变; 运算符的相对次序不同; 中缀式丢失了括弧信息，致使运算的次序不确定 前缀式的运算规则为:连续出现的两个操作数和在它们之前且紧靠它们的运算符构成一个最小表达式 后缀式的运算规则为:运算符在式中出现的顺序恰为表达式的运算顺序;每个运算符和在它之前出现且紧靠它的两个操作数构成一个最小表达式。 实现递归：多个函数嵌套调用的规则是：后调用先返回。 浏览器历史纪录，Android中的最近任务，Activity的启动模式，CPU中栈的实现，Word自动保存，解析计算式，解析xml/json。解析XML时，需要校验节点是否闭合，节点闭合的话，有头尾符号相对应，遇到头符号将其放入栈中，遇到尾符号时，弹出栈的内容，看是否有与之对应的头符号，栈的特性刚好符合符号匹配的就近原则。 不是所有的递归程序都需要栈来保护现场，比方说求阶乘的，是单向递归，直接用循环去替代从1乘到n就是结果了，另外一些需要栈保存的也可以用队列等来替代。不是所有的递归转化为非递归都要用到栈。转化为非递归主要有两种方法：对于尾递归或单向递归，可以用循环结构算法代替。 队列队列(Queue)也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。先进先出。 顺序队列：顺序存储结构。当头尾指针相等时队列为空。在非空队列里，头指针始终指向队头前一个位置，而尾指针始终指向队尾元素的实际位置 循环队列。在循环队列中进行出队、入队操作时，头尾指针仍要加1，朝前移动。只不过当头尾指针指向向量上界（MaxSize-1）时，其加1操作的结果是指向向量的下界0。除非向量空间真的被队列元素全部占用，否则不会上溢。因此，除一些简单的应用外，真正实用的顺序队列是循环队列。故队空和队满时头尾指针均相等。因此，我们无法通过front=rear来判断队列“空”还是“满” 链队列：链式存储结构。限制仅在表头删除和表尾插入的单链表。显然仅有单链表的头指针不便于在表尾做插入操作，为此再增加一个尾指针，指向链表的最后一个结点。 设尾指针的循环链表表示队列,则入队和出队算法的时间复杂度均为O(1)。用循环链表表示队列，必定有链表的头结点，入队操作在链表尾插入，直接插入在尾指针指向的节点后面，时间复杂度是常数级的；出队操作在链表表头进行，也就是删除表头指向的节点，时间复杂度也是常数级的。 队空条件：rear==front，但是一般需要引入新的标记来说明栈满还是栈空，比如每个位置布尔值 队满条件：(rear+1) % QueueSize==front，其中QueueSize为循环队列的最大长度 计算队列长度：（rear-front+QueueSize）% QueueSize 入队：（rear+1）% QueueSize 出队：（front+1）% QueueSize 假设以数组A[N]为容量存放循环队列的元素,其头指针是front,当前队列有X个元素,则队列的尾指针值为(front+X mod N) 串 串(String)是零个或多个字符组成的有限序列。长度为零的串称为空串(Empty String)，它不包含任何字符。通常将仅由一个或多个空格组成的串称为空白串(Blank String) 注意：空串和空白串的不同，例如“ ”和“”分别表示长度为1的空白串和长度为0的空串。 串的表示和实现： 定长顺序存储表示。静态存储分配的顺序表。 堆分配存储表示。存储空间是在程序执行过程中动态分配而得。所以也称为动态存储分配的顺序表 串的链式存储结构。串匹配：将主串称为目标串，子串称之为模式串。蛮力法匹配。KMP算法匹配。Boyer-Moore算法匹配。 数组和广义表 数组和广义表可看成是一种特殊的线性表，其特殊在于: 表中的元素本身也是一种线性表。内存连续。根据下标在O(1)时间读/写任何元素。 二维数组，多维数组，广义表、树、图都属于非线性结构 数组数组的顺序存储：行优先顺序；列优先顺序。数组中的任一元素可以在相同的时间内存取，即顺序存储的数组是一个随机存取结构。关联数组(Associative Array)，又称映射（Map）、字典（ Dictionary）是一个抽象的数据结构，它包含着类似于(键，值)的有序对。 不是线性表。矩阵的压缩： 对称矩阵、三角矩阵：直接存储矩阵的上三角或者下三角元素。注意区分i&gt;=j和i 广义表广义表（Lists，又称列表）是线性表的推广。广义表是n(n≥0)个元素a1,a2,a3,…,an的有限序列，其中ai或者是原子项，或者是一个广义表。若广义表LS（n&gt;=1)非空，则a1是LS的表头，其余元素组成的表(a2,…an)称为LS的表尾。广义表的元素可以是广义表，也可以是原子，广义表的元素也可以为空。表尾是指除去表头后剩下的元素组成的表，表头可以为表或单元素值。所以表尾不可以是单个元素值。 例子： A=（）——A是一个空表，其长度为零。 B=（e）——表B只有一个原子e，B的长度为1。、 C=（a,(b,c,d))——表C的长度为2，两个元素分别为原子a和子表(b,c,d)。 D=（A，B，C）——表D的长度为3，三个元素都是广义 表。显然，将子表的值代入后，则有D=(( ),(e),(a,(b,c,d)))。 E=（a,E）——这是一个递归的表，它的长度为2，E相当于一个无限的广义表E=(a,(a,(a,(a,…)))). 三个结论： 广义表的元素可以是子表，而子表的元素还可以是子表。由此，广义表是一个多层次的结构，可以用图形象地表示 广义表可为其它表所共享。例如在上述例4中，广义表A，B，C为D的子表，则在D中可以不必列出子表的值，而是通过子表的名称来引用。 广义表的递归性 考点： 广义表是0个或多个单因素或子表组成的有限序列，广义表可以是自身的子表，广义表的长度n&gt;=0，所以可以为空表。广义表的同级元素(直属于同一个表中的各元素)具有线性关系 广义表的表头为空，并不代表该广义表为空表。广义表()和(())不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；而后者是长度为l的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表() 已知广义表LS＝((a,b,c),(d,e,f)),运用head和tail函数取出LS中原子e的运算是head(tail(head(tail(LS)))。根据表头、表尾的定义可知：任何一个非空广义表的表头是表中第一个元素，它可以是原子，也可以是子表，而其表尾必定是子表。也就是说，广义表的head操作，取出的元素是什么，那么结果就是什么。但是tail操作取出的元素外必须加一个表——“（）“。tail(LS)＝((d,e,f))；head(tail(LS))=(d,e,f)；tail(head(tail(LS)))=(e,f)；head(tail(head(tail(LS))))=e。 二维以上的数组其实是一种特殊的广义表 在（非空）广义表中：1、表头head可以是原子或者一个表 2、表尾tail一定是一个表 3.广义表难以用顺序存储结构 4.广义表可以是一个多层次的结构 树和二叉树 树一种非线性结构。树是递归结构，在树的定义中又用到了树的概念。基本术语： 树结点：包含一个数据元素及若干指向子树的分支； 孩子结点：结点的子树的根称为该结点的孩子； 双亲结点：B结点是A结点的孩子，则A结点是B结点的双亲； 兄弟结点：同一双亲的孩子结点； 堂兄结点：同一层上结点； 结点层次：根结点的层定义为1；根的孩子为第二层结点，依此类推； 树的高（深）度：树中最大的结点层 结点的度：结点子树的个数 树的度： 树中最大的结点度。 叶子结点：也叫终端结点，是度为0的结点； 分枝结点：度不为0的结点（非终端结点）； 森林：互不相交的树集合； 有序树：子树有序的树，如：家族树； 无序树：不考虑子树的顺序； 二叉树二叉树可以为空。二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树。这是二叉树与树的最主要的差别。注意区分： 二叉树、二叉查找树/二叉排序树/二叉搜索树、二叉平衡(查找)树 二叉平衡树肯定是一颗二叉排序树。堆不是一颗二叉平衡树。 二叉树不等价于分支树最多为二的有序树。当一个结点只包含一个子节点时，对于有序树并无左右孩子之分，而对于二叉树来说依然有左右孩子之分，所以二叉树与树是两种不同的结构。 性质： 在二叉树的第 i 层上至多有2i-1个结点。 深度为 k 的二叉树上至多含 2k-1 个结点（k≥1） 对任何一棵二叉树，若它含有n0个叶子结点、n2个度为 2 的结点，则必存在关系式：n0= n2+1。 具有 n 个结点的完全二叉树的深度为⎣log2 n⎦+1 。 n个结点的二叉树中，完全二叉树具有最小的路径长度。 如果对一棵有n个结点的完全二叉树的结点按层序编号,则对任一结点i（1&lt;=i&lt;=n),有： 如果i＝1，则结点i无双亲，是二叉树的根；如果i&gt;1，则其双亲的编号是 i/2(整除）。 如果2i&gt;n，无左孩子；否则，其左孩子是结点2i。 如果2i＋1&gt;n，则结点i无右孩子；否则，其右孩子是结点2i＋1。 二叉树的存储结构 顺序存储结构：仅仅适用于满或完全二叉树，结点之间的层次关系由性质5确定。 二叉链表法：每个节点存储左子树和右子树。三叉链表：左子树、右子树、父节点，总的指针是n+2 在有n个结点的二叉链表中，值为非空的链域的个数为n-1。在有N个结点的二叉链表中必定有2N个链域。除根结点外，其余N-1个结点都有一个父结点。所以，一共有N-1个非空链域，其余2N-(N-1)=N+1个为空链域。 二叉链存储法也叫孩子兄弟法，左指针指向左孩子，右指针指向右兄弟。而中序遍历的顺序是左孩子，根，右孩子。这种遍历顺序与存储结构不同，因此需要堆栈保存中间结果。而中序遍历检索二叉树时，由于其存储结构跟遍历顺序相符，因此不需要用堆栈。 遍历二叉树和线索二叉树遍历二叉树：使得每一个结点均被访问一次，而且仅被访问一次。非递归的遍历实现要利用栈。 先序遍历DLR：根节点-&gt;左子树-&gt;右子树 中序遍历LDR：左子树-&gt;根节点-&gt;右子树。必须要有中序遍历才能得到一棵二叉树的正确顺序 后续遍历LRD：左子树-&gt;右子树-&gt;根节点。需要栈的支持。 层次遍历：用一维数组存储二叉树时,总是以层次遍历的顺序存储结点。层次遍历应该借助队列。 线索二叉树：对二叉树所有结点做某种处理可在遍历过程中实现；检索（查找）二叉树某个结点，可通过遍历实现；如果能将二叉树线索化，就可以简化遍历算法，提高遍历速度，目的是加快查找结点的前驱或后继的速度。 如何线索化？以中序遍历为例，若能将中序序列中每个结点前趋、后继信息保存起来，以后再遍历二叉树时就可以根据所保存的结点前趋、后继信息对二叉树进行遍历。对于二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前结点左，右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点的线索。前驱就是在这一点之前走过的点，不是下一将要去往的点。 加上结点前趋后继信息（结索）的二叉树称为线索二叉树。n个结点的线索二叉树上每个结点有2个指针域（指向左孩子和右孩子），总共有2n个指针域；一个n个结点的树有n-1条边，那么空指针域= 2n - (n-1) = n + 1，即线索数为n+1。指针域tag为0，存放孩子指针，为1，存放前驱/后继节点指针。 线索树下结点x的前驱与后继查找：设结点x相应的左（右）标志是线索标志，则lchild(rchild)就是前驱(后继），否则： LDR–前驱：左子树中最靠右边的结点；后继：右子树中最靠左边的结点 LRD–前驱：右子树的根，若无右子树，为左子树跟。后继：x是根，后继是空；x是双亲的右孩子、x是双亲的左孩子，但双亲无右孩子，双亲是后继；x是双亲的左孩子，双亲有右孩子，双亲右子树中最左的叶子是后继 DLR–对称于LRD线索树—将LRD中所有左右互换，前驱与后继互换，得到DLR的方法。 为简化线索链表的遍历算法，仿照线性链表，为线索链表加上一头结点，约定： 头结点的lchild域：存放线索链表的根结点指针； 头结点的rchild域: 中序序列最后一个结点的指针； 中序序列第一结点lchild域指向头结点; 中序序列最后一个结点的rchild域指向头结点; 中序遍历的线索二叉树以及线索二叉树链表示意图 : 一棵左右子树均不空的二叉树在前序线索化后,其中空的链域的个数是1。前序和后续线索化后空链域个数都是1，中序是2。二叉树在线索化后，仍不能有效求解的问题是前序求前序先驱，后序求后序后继。 中序遍历的顺序为：左、根、右，所以对于每一非空的线索，左子树结点的后继为根结点，右子树结点的前驱为根结点，再递归的执行上面的过程，可得非空线索均指向其祖先结点。在中序线索二叉树中,每一非空的线索均指向其祖先结点。 在二叉树上加上结点前趋、后继线索后，可利用线索对二叉树进行遍历,此时，不需栈，也不需递归。基本步骤： p=T-&gt;lchild; p指向线索链表的根结点； 若线索链表非空，循环： 循环，顺着p左孩子指针找到最左下结点；访问之； 若p所指结点的右孩子域为线索，p的右孩子结点即为后继结点循环： p=p-&gt;rchild； 并访问p所指结点；（在此循环中，顺着后继线索访问二叉树中的结点） 一旦线索“中断”，p所指结点的右孩子域为右孩子指针，p=p-&gt;rchild，使 p指向右孩子结点； 树和森林 树的存储结构： 双亲表示法 孩子表示法 利用图表示树 孩子兄弟表示法（二叉树表示法）：链表中每个结点的两指针域分别指向其第一个孩子结点和下一个兄弟结点 将树转化成二叉树：右子树一定为空 加线：在兄弟之间加一连线 抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系 旋转：以树的根结点为轴心，将整树顺时针转45° 森林转换成二叉树： 将各棵树分别转换成二叉树 将每棵树的根结点用线相连 以第一棵树根结点为二叉树的根 树与转换后的二叉树的关系：转换后的二叉树的先序对应树的先序遍历；转换后的二叉树的中序对应树的后序遍历 哈弗曼树/霍夫曼树 一些概念 路径：从一个祖先结点到子孙结点之间的分支构成这两个结点间的路径； 路径长度：路径上的分支数目称为路径长度； 树的路径长度：从根到每个结点的路径长度之和。 结点的权：根据应用的需要可以给树的结点赋权值； 结点的带权路径长度：从根到该结点的路径长度与该结点权的乘积； 树的带权路径长度=树中所有叶子结点的带权路径之和；通常记作 WPL=∑wi×li 哈夫曼树：假设有n个权值(w1, w2, … , wn)，构造有n个叶子结点的二叉树，每个叶子结点有一个 wi作为它的权值。则带权路径长度最小的二叉树称为哈夫曼树。最优二叉树。前缀码的定义：在一个字符集中，任何一个字符的编码都不是另一个字符编码的前缀。霍夫曼编码就是前缀码，可用于快速判断霍夫曼编码是否正确。霍夫曼树是满二叉树，若有n个节点，则共有(n+1)/2个码子 给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为霍夫曼树(Huffman Tree)。霍夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 假设哈夫曼树是二叉的话，则度为0的结点个数为N，度为2的结点个数为N-1，则结点总数为2N-1。哈夫曼树的结点个数必为奇数。 哈夫曼树不一定是完全二叉树，但一定是最优二叉树。 若度为m的哈夫曼树中,其叶结点个数为n,则非叶结点的个数为[(n-1)/(m-1)]。边的数目等于度。 图遍历与回溯 图搜索-&gt;形成搜索树 穷举法。 贪心法。多步决策，每步选择使得构成一个问题的可能解，同时满足目标函数。 回溯法。根据题意，选取度量标准，然后将可能的选择方法按度量标准所要求顺序排好，每次处理一个量，得到该意义下的最优解的分解处理。图 无向图 回路或环：第一个顶点和最后一个顶点相同的路径。 简单回路或简单环：除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路 连通：顶点v至v’ 之间有路径存在 连通图：无向图图 G 的任意两点之间都是连通的，则称G是连通图。 连通分量：极大连通子图，子图中包含的顶点个数极大 所有顶点度的和必须为偶数 有向图： 回路或环：第一个顶点和最后一个顶点相同的路径。 简单回路或简单环：除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路。 连通：顶点v至v’之间有路径存在 强连通图：有向图G的任意两点之间都是连通的，则称G是强连通图。各个顶点间均可达。 强连通分量：极大连通子图 有向图顶点的度是顶点的入度与出度之和。邻接矩阵中第V行中的1的个数是V的出度 生成树：极小连通子图。包含图的所有n个结点，但只含图的n-1条边。在生成树中添加一条边之后，必定会形成回路或环。 完全图：有 n(n-1)/2 条边的无向图。其中n是结点个数。必定是连通图。 有向完全图：有n(n-1)条边的有向图。其中n是结点个数。每两个顶点之间都有两条方向相反的边连接的图。 一个无向图 G=(V,E) 是连通的，那么边的数目大于等于顶点的数目减一：|E|&gt;=|V|-1，而反之不成立。如果 G=(V,E) 是有向图，那么它是强连通图的必要条件是边的数目大于等于顶点的数目：|E|&gt;=|V|，而反之不成立。没有回路的无向图是连通的当且仅当它是树，即等价于：|E|=|V|-1。 图的存储形式 邻接矩阵和加权邻接矩阵 无权有向图：出度: i行之和；入度: j列之和。 无权无向图：i结点的度: i行或i列之和。 加权邻接矩阵：相连为w，不相连为∞ 邻接表 用顶点数组表、边（弧）表表示该有向图或无向图 顶点数组表：用数组存放所有的顶点。数组大小为图顶点数n 边表（边结点表）：每条边用一个结点进行表示。同一个结点的所有的边形成它的边结点单链表。 n个顶点的无向图的邻接表最多有n(n-1)个边表结点。有n个顶点的无向图最多有n(n-1)/2条边，此时为完全无向图，而在邻接表中每条边存储两次，所以有n(n-1)个结点 图的遍历深度优先搜索利用栈，广度优先搜索利用队列 求一条从顶点i到顶点s的简单路径–深搜。求两个顶点之间的一条长度最短的路径–广搜。当各边上的权值均相等时,BFS算法可用来解决单源最短路径问题。 生成树和最小生成树 每次遍历一个连通图将图的边分成遍历所经过的边和没有经过的边两部分，将遍历经过的边同图的顶点构成一个子图，该子图称为生成树。因此有DFS生成树和BFS生成树。 生成树是连通图的极小子图，有n个顶点的连通图的生成树必定有n-1条边,在生成树中任意增加一条边，必定产生回路。若砍去它的一条边，就会把生成树变成非连通子图 最小生成树：生成树中边的权值(代价)之和最小的树。最小生成树问题是构造连通网的最小代价生成树。 Kruskal算法：令最小生成树集合T初始状态为空，在有n个顶点的图中选取代价最小的边并从图中删去。若该边加到T中有回路则丢弃，否则留在T中；依此类推，直至T中有n-1条边为止。 Prim算法、Kruskal算法和Dijkstra算法均属于贪心算法。 Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。 Dijkstra算法解决了从某个原点到其余各顶点的最短路径问题，由循环嵌套可知该算法的时间复杂度为O(N·N)。若要求任一顶点到其余所有顶点的最短路径，一个比较简单的方法是对每个顶点当做源点运行一次该算法，等于在原有算法的基础上，再来一次循环，此时整个算法的复杂度就变成了O(N·N·N)。 Bellman-Ford算法解决的是一般情况下的单源最短路径问题，在这里，边的权重可以为负值。该算法返回一个布尔值，以表明是否存在一个从源节点可以到达的权重为负值的环路。如果存在这样一个环路，算法将告诉我们不存在解决方案。如果没有这种环路存在，算法将给出最短路径和它们的权重。 双连通图和关节点 若从一个连通图中删去任何一个顶点及其相关联的边，它仍为一个连通图的话，则该连通图被称为重（双）连通图。 若连通图中的某个顶点和其相关联的边被删去之后，该连通图被分割成两个或两个以上的连通分量，则称此顶点为关节点。 没有关节点的连通图为双连通图 若生成树的根结点，有两个或两个以上的分支，则此顶点(生成树的根)必为关节点； 对生成树上的任意一个非叶“顶点”，若其某棵子树中的所有“顶点”没有和其祖先相通的回边，则该“顶点”必为关节点。 有向无环图及其应用 拓扑排序。在用邻接表表示图时,对有n个顶点和e条弧的有向图而言时间复杂度为O(n+e)。一个有向图能被拓扑排序的充要条件就是它是一个有向无环图。拓扑序列唯一不能唯一确定有向图。 AOV网(Activity On Vertex)：用顶点表示活动，边表示活动的优先关系的有向图称为AOV网。AOV网中不允许有回路，这意味着某项活动以自己为先决条件。 拓扑有序序列：把AOV网络中各顶点按照它们相互之间的优先关系排列一个线性序列的过程。若vi是vj前驱，则vi一定在vj之前；对于没有优先关系的点，顺序任意。 拓扑排序：对AOV网络中顶点构造拓扑有序序列的过程。方法： 在有向图中选一个没有前驱的顶点且输出之 从图中删除该顶点和所有以它为尾的弧 重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止(此时说明图中有环）采用深度优先搜索或拓扑排序算法可以判断出一个有向图中是否有环(回路).深度优先搜索只要在其中记录下搜索的节点数n，当n大于图中节点数时退出，并可以得出有回路。若有回路，则拓扑排序访问不到图中所有的节点，所以也可以得出回路。广度优先搜索过程中如果访问到一个已经访问过的节点，可能是多个节点指向这个节点，不一定是存在环。 算法描述： 把邻接表中入度为0的顶点依此进栈 若栈不空，则 栈顶元素vj退栈并输出； 在邻接表中查找vj的直接后继vk，把vk的入度减1；若vk的入度为0则进栈 若栈空时输出的顶点个数不是n，则有向图有环；否则，拓扑排序完毕。AOE网：带权的有向无环图，其中顶点表示事件，弧表示活动，权表示活动持续时间。在工程上常用来表示工程进度计划。 一些定义： 事件的最早发生时间（ve(j)）：从源点到j结点的最长的路径。意味着事件最早能够发生的时间。 事件的最迟发生时间（vl(j)）：不影响工程的如期完工，事件j必须发生的时间。 查找 顺序查找、折半查找、索引查找、分块查找是静态查找，动态查找有二叉排序树查找，最优二叉树查找，键树查找，哈希表查找 静态查找表顺序表的顺序查找：应用范围：顺序表或线性链表表示的表，表内元素之间无序。查找过程：从表的一端开始逐个进行记录的关键字和给定值的比较。 顺序有序表的二分查找。平均查找时间(n+1)/n log2(n+1) 分块查找：将表分成几块，块内无序，块间有序，即前一块中的最大值小于后一块中的最小值。并且有一张索引表，每一项存放每一块的最大值和指向该块第一个元素的指针。索引表有序，块内无序。所以，块间查找用二分查找，块内用顺序查找，效率介于顺序和二分之间；先确定待查记录所在块，再在块内查找。因此跟表中元素个数和块中元素个数都有关。 用数组存放待查记录, 建立索引表，由每块中最大（小）的关键字及所属块位置的信息组成。 当索引表较大时，可以采用二分查找 在数据量极大时，索引可能很多，可考虑建立索引表的索引，即二级索引，原则上索引不超过三级分块查找平均查找长度：ASLbs = Lb + Lw。其中，Lb是查找索引表确定所在块的平均查找长度， Lw是在块中查找元素的平均查找长度。在n一定时，可以通过选择s使ASL尽可能小。当s=sqrt(n)时，ASL最小。 时间：顺序查找最差，二分最好，分块介于两者之间 空间：分块最大，需要增加索引数据的空间 顺序查找对表没有特殊要求 分块时数据块之间在物理上可不连续。所以可以达到插入、删除数据只涉及对应的块；另外，增加了索引的维护。 二分查找要求表有序，所以若表的元素的插入与删除很频繁，维持表有序的工作量极大。 在表不大时，一般直接使用顺序查找。 动态查找二叉排序树的结点删除： x为叶子结点，则直接删除 x只有左子树xL或只有右子树xR ,则令xL或xR直接成为双亲结点f的子树； x即有左子树xL也有右子树xR，在xL中选值最大的代替x，该数据按二叉排序树的性质应在最右边。平衡二叉树：每个结点的平衡因子都为 1、－1、0 的二叉排序树。或者说每个结点的左右子树的高度最多差1的二叉排序树。 平衡二叉树的平衡： 左调整(新结点插入在左子树上的调整)： LL(插入在结点左子树的左子树上)：旋转前后高度都为h+1 LR(新插入结点在左子树的右子树上)：旋转前后高度仍为h+1 右调整(新结点插入在右子树上进行的调整): RR(插入在的右子树的右子树上)：处理方法和 LL对称 RL(插入在的右子树的左子树上)：处理方法和 LR对称平衡树建立方法： 按二叉排序树插入结点 如引起结点平衡因子变为|2|，则确定旋转点，该点是离根最远（或最接近于叶子的点） 确定平衡类型后进行平衡处理，平衡后以平衡点为根的子树高不变 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。常见的平衡二叉树： 红黑树是平衡二叉树，也就是左右子树是平衡的，高度大概相等。这种情况等价于一块完全二叉树的高度，查找的时间复杂度是树的高度，为logn，插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn) 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是NIL节点）。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有简单路径 都包含相同数目的黑色节点。 avl树也是自平衡二叉树；红黑树和AVL树查找、插入、删除的时间复杂度相同；包含n个内部结点的红黑树的高度是o(logn); TreeMap 是一个红黑树的实现，能保证插入的值保证排序 STL和linux多使用红黑树作为平衡树的实现： 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。 map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。 查找总结 既希望较快的查找又便于线性表动态变化的查找方法是哈希法查找。二叉排序树查找，最优二叉树查找，键树查找，哈希法查找是动态查找。分块、顺序、折半、索引顺序查找均为静态。分块法应该是将整个线性表分成若干块进行保存，若动态变化则可以添加在表的尾部（非顺序结构），时间复杂度是O(1)，查找复杂度为O(n)；若每个表内部为顺序结构，则可用二分法将查找时间复杂度降至O(logn)，但同时动态变化复杂度则变成O(n)；顺序法是挨个查找，这种方法最容易实现，不过查找时间复杂度都是O(n)，动态变化时可将保存值放入线性表尾部，则时间复杂度为O(1)；二分法是基于顺序表的一种查找方式，时间复杂度为O(logn)；通过哈希函数将值转化成存放该值的目标地址，O（1） 二叉树的平均查找长度为O(log2n)——O(n).二叉排序树的查找效率与二叉树的高度有关，高度越低，查找效率越高。二叉树的查找成功的平均查找长度ASL不超过二叉树的高度。二叉树的高度与二叉树的形态有关，n个节点的完全二叉树高度最小，高度为[log2n]+1,n个节点的单只二叉树的高度最大，高度为n，此时查找成功的ASL为最大(n+1)/2，因此二叉树的高度范围为[log2n]+1——n. 链式存储不能随机访问，必须是顺序存储 B-树、B+树 B-树B-树就是B树。m阶B-树是满足或空，或满足下列性质的m叉树： 树中每个结点最多有m棵子树 根结点在不是叶子时，至少有两棵子树 除根外，所有非终端结点至少有⎡m/2⎤棵子树 有s个子树的非叶结点具有 n = s-1个关键字，结点的信息组织为:(n,A0,K1,A1,K2,A2 … Kn，4An)。这里：n为关键字的个数，ki（i=1,2,…,n)为关键字，且满足Ki小于Ki+1,，Ai(i=0,1,..n)为指向子树的指针。 所有的叶子结点都出现在同一层上，不带信息（可认为外部结点或失败结点）。 关键字集合分布在整颗树中 任何一个关键字出现且只出现在一个结点中 搜索有可能在非叶子结点结束 其搜索性能等价于在关键字全集内做一次二分查找 只适用于随机检索，不适用于顺序检索。 有结点的平衡因子都为零 M阶B-树中含有N个关键字，最大深度为log⎡m/2⎤(n+1)/2+2 B-树中结点的插入 m代表B-树的阶，插入总发生在最低层 插入后关键字个数小于等于 m-1,完成。 插入后关键字个数等于m,结点分裂，以中点数据为界一分为二，中点数据放到双亲结点中。这样就有可能使得双亲结点的数据个数为m,引起双亲结点的分裂，最坏情况下一直波及到根，引起根的分裂——B-树长高。 3阶B-树的插入。每个结点最多3棵子树，2个数据；最少2棵子树，1个数据。所以3阶B-树也称为2-3树。 B-树中结点的删除 删除发生在最底层 被删关键字所在结点中的关键字数目大于等于 m/2 ，直接删除。 删除后结点中数据为⎡m/2⎤-2，而相邻的左（右）兄弟中数据大于⎡m/2⎤-1，此时左（右兄弟）中最大（小）的数据上移到双亲中，双亲中接（靠）在它后（前）面的数据移到被删数据的结点中 其左右兄弟结点中数据都是⎡m/2⎤-1，此时和左（右）兄弟合并，合并时连同双亲中相关的关键字。此时，双亲中少了一项，因此又可能引起双亲的合并，最坏一直到根，使B-树降低一层。 删除不在最底层 在大于被删数据中选最小的代替被删数据，问题转换成在最底层的删除 B+树在实际的文件系统中，用的是B+树或其变形。有关性质与操作类似与B-树。 差异： 有n棵子树的结点中有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。 所有叶子结点中包含全部关键字信息，及对应记录位置信息及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。(而B树的叶子节点并没有包括全部需要查找的信息) 所有非叶子为索引，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B树的非终节点也包含需要查找的有效信息)非叶最底层顺序联结，这样可以进行顺序查找B+特性 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 不可能在非叶子结点命中 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层 更适合文件索引系统 B+树插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn) 查找过程 在 B+ 树上，既可以进行缩小范围的查找，也可以进行顺序查找； 在进行缩小范围的查找时，不管成功与否，都必须查到叶子结点才能结束； 若在结点内查找时，给定值≤Ki， 则应继续在 Ai 所指子树中进行查找插入和删除的操作：类似于B_树进行，即必要时，也需要进行结点的“分裂”或“合并”。 为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据库索引？ B+tree的磁盘读写代价更低 B+tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B树就比B+树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。 B+tree的查询效率更加稳定 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 B树和B+树都是平衡的多叉树。B树和B+树都可用于文件的索引结构。B树和B+树都能有效的支持随机检索。B+树既能索引查找也能顺序查找. 哈希表 在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样不经过比较，一次存取就能得到元素。 哈希函数——在记录的关键字与记录的存储位置之间建立的一种对应关系。是从关键字空间到存储位置空间的一种映象。 哈希表——应用哈希函数，由记录的关键字确定记录在表中的位置信息，并将记录根据此信息放入表中，这样构成的表叫哈希表。 Hash查找适合于关键字可能出现的值的集合远远大于实际关键字集合的情形。 更适合查找，不适合频繁更新 Hash表等查找复杂依赖于Hash值算法的有效性，在最好的情况下，hash表查找复杂度为O(1)。只有无冲突的hash_table复杂度才是O(1)。一般是O(c)，c为哈希关键字冲突时查找的平均长度。插入，删除，查找都是O(1)。平均查找长度不随表中结点数目的增加而增加,而是随负载因子的增大而增大 由于冲突的产生，使得哈希表的查找过程仍然是一个给定值与关键字比较的过程。根据抽屉原理，冲突是不可能完全避免的，所以，选择好的散列函数和冲突处理方法： 1.构造一个性能好，冲突少的Hash函数2.如何解决冲突… 常用的哈希函数 直接定址法。仅适合于：地址集合的大小 == 关键字集合的大小 数字分析法。对关键字进行分析，取关键字的若干位或其组合作哈希地址。仅适合于：能预先估计出全体关键字的每一位上各种数字出现的频度。 平方取中法。以关键字的平方值的中间几位作为存储地址。 折叠法。将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）做哈希地址。移位叠加/间界叠加。适合于: 关键字的数字位数特别多，且每一位上数字分布大致均匀情况。 除留余数法。取关键字被某个不大于哈希表表长m的数p除后所得余数作哈希地址，即H(key)=key%p，p&lt;=m。 随机数法。取关键字的伪随机函数值作哈希地址，即H(key)=random(key)，适于关键字长度不等的情况。 冲突解决 开放定址法。当冲突发生时，形成一个探查序列；沿此序列逐个地址探查，直到找到一个空位置（开放的地址），将发生冲突的记录放到该地址中。即Hi=(H(key)+di) % m，i=1,2,……k(k&lt;=m-1)，H(key)哈希函数，m哈希表长，di增量序列。缺点：删除：只能作标记，不能真正删除；溢出；载因子过大、解决冲突的算法选择不好会发生聚集问题。要求装填因子α较小，故当结点规模较大时会浪费很多空间。 线性探测再散列：di=1，2，3，…，m-1 二次探测再散列：di=12,-12,22,-22,…，±k2（k&lt;=m/2） 伪随机探测再散列: di为伪随机数序列 链地址法：将所有关键字为同义词的记录存储在一个单链表中，并用一维数组存放头指针。拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间。一旦发生冲突，在当前位置给单链表增加结点就行。 其他方法：再哈希法、建立公共溢出区 在用拉链法构造的散列表中，删除结点的操作易于实现。拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间。由于拉链法中各链表上的结点空间是动态申请的,故它更适合于造表前无法确定表长的情况。拉链法解决冲突时，需要使用指针，指示下一个元素的存储位置 开哈希表–链式地址法;闭哈希表–开放地址法.开哈希和闭哈希主要的区别在于，随着哈希表的密集度提高，使用闭哈希时，不仅会与相同哈希值的元素发生冲突，还容易与不同哈希值的元素发生冲突；而开哈希则不受哈希表疏密与否的影响，始终只会与相同哈希值的元素冲突而已。所以在密集度变大的哈希表中查找时，显然开哈希的平均搜索长度不会增长。 设有n个关键字具有相同的Hash函数值，则用线性探测法把这n个关键字映射到Hash表中需要做n(n-1)/2次线性探测。如果使用二次探测再散列法将这n个关键字存入哈希表，至少要进行n(n+1)/2次探测 Hash查找效率：装填因子=表中记录数/表容量 有B+Tree/Hash_Map/STL Map三种数据结构。对于内存中数据，查找性能较好的数据结构是Hash_Map，对于磁盘中数据，查找性能较好的数据结构是B+Tree。Hash操作能根据散列值直接定位数据的存储地址，设计良好的hash表能在常数级时间下找到需要的数据，但是更适合于内存中的查找。B+树是一种是一种树状的数据结构，适合做索引，对磁盘数据来说，索引查找是比较高效的。STL_Map的内部实现是一颗红黑树，但是只是一颗在内存中建立二叉树树，不能用于磁盘操作，而其内存查找性能也比不上Hash查找。 排序 内部排序：全部数据可同时放入内存进行的排序。 外部排序：文件中数据太多，无法全部调入内存进行的排序。 内部排序插入类： 直接插入排序。最坏情况是数据递减序，数据比较和移动量最大，达到O(n2)，最好是数据是递增序，比较和移动最少为O(n)。趟数是固定的n-1，即使有序，也要依次从第二个元素开始。排序趟数不等于时间复杂度。 折半插入排序 。由于插入第i个元素到r[1]到r[i-1]之间时，前i个数据是有序的，所以可以用折半查找确定插入位置，然后插入。 希尔排序。缩小增量排序。5-3-1。在实际应用中，步长的选取可简化为开始为表长n的一半（n/2），以后每次减半，最后为1。插入的改进，最后一趟已基本有序，比较次数和移动次数相比直接插入最后一趟更少 交换类： 冒泡排序。O(n2)通常认为冒泡是比较差的，可以加些改进，比如在一趟中无数据的交换，则结束等措施。 在数据已基本有序时，冒泡是一个较好的方法 在数据量较少时（15个左右）可以用冒泡 快速排序。 时间复杂度。最好情况：每次支点总在中间，O(nlog2n)，平均O(nlog2n)。最坏，数据已是递增或递减，O(n2)。pivotkey的选择越靠近中央，即左右两个子序列长度越接近，排序速度越快。越无序越快。 空间复杂度。需栈空间以实现递归，最坏情况：S(n)=O(n)；一般情况：S(n)=O(log2n) 在序列已是有序的情况下，时间复杂度最高。原因：支点选择不当。改进：随机选取支点或最左、最右、中间三个元素中的值处于中间的作为支点，通常可以避免最坏情况。所以，快速排序在表已基本有序的情况下不合适。 在序列长度已较短时，采用直接插入排序、起泡排序等排序方法。序列的个数通常取10左右。 选择类排序： 简单选择排序。O(n2)。总比较次数n(n-1)/2。 堆排序。建堆 O(n)，筛选排序O(nlogn)。找出若干个数中最大/最小的前K个数，用堆排序是最好。小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于[n/2]。时间复杂度不会因为待排序序列的有序程度而改变，但是待排序序列的有序程度会影响比较次数。 归并排序。时间：与表长成正比，若一个表表长是m，另一个是n，则时间是O(m+n)。单独一个数组归并，时间：O(nlogn)，空间：O(n)，比较次数介于(nlogn)/2和(nlogn)-n+1，赋值操作的次数是(2nlogn)。归并排序算法比较占用内存，但却是效率高且稳定的排序算法。在外排序中使用。归并的趟数是logn。 基数排序。在一般情况下，每个结点有 d 位关键字，必须执行 t = d次分配和收集操作。分配的代价：O(n)；收集的代价：O(rd) （rd是基数）；总的代价为：O( d ×(n + rd))。适用于以数字和字符串为关键字的情况。 枚举排序，通常也被叫做秩排序，比较计数排序。对每一个要排序的元素，统计小于它的所有元素的个数，从而得到该元素在整个序列中的位置，时间复杂度为O(n2) 比较法分类的下界：O(nlogn) 排序算法的一些特点： 堆排序、冒泡排序、快速排序在每趟排序过程中,都会有一个元素被放置在其最终的位置上。 有字符序列 ｛Q,H,C,Y,P,A,M,S,R,D,F,X｝ ,新序列{F,H,C,D,P,A,M,Q,R,S,Y,X}，是快速排序算法一趟扫描的结果。(拿Q作为分割点,快速排序一轮。二路归并，第一趟排序，得到 n / 2 个长度为 2 的各自有序的子序列，第二趟排序，得到 n / 4 个长度为 4 的各自有序的子序列H Q C Y A P M S D R F X。如果是快速排序的话，第一个元素t将会被放到一个最准确的位置，t前的数均小于t，后面的数均大于t。希尔排序每个小分组内将会是有序的。堆排序，把它构成一颗二叉树的时候，该堆要么就是大根堆，要么就是小根堆，第一趟Y排在最后；冒泡，那么肯定会有数据下沉的动作，第一趟有A在第一位。) 在文件”局部有序”或文件长度较小的情况下,最佳内部排序的方法是直接插入排序。（归并排序要求待排序列已经部分有序，而部分有序的含义是待排序列由若干有序的子序列组成，即每个子序列必须有序，并且其时间复杂度为O(nlog2n)；直接插入排序在待排序列基本有序时，每趟的比较次数大为降低，即n-1趟比较的时间复杂度由O(n^2)降至O(n)。在待排序的元素序列基本有序或者每个元素距其最终位置不远也可用插入排序，效率最高的排序方法是插入排序） 排序趟数与序列的原始状态有关的排序方法是优化冒泡和快速排序法。(插入排序和选择排序不管序列的原始状态是什么都要执行n-1趟，优化冒泡和快排不一定。仔细理解排序的次数和比较次数的区别) 不稳定的排序方法：快排，堆排，希尔，选择 要与关键字的初始排列次序无关,那么就是最好、最坏、一般的情况下排序时间复杂度不变, 总共有堆排序,归并排序,选择排序,基数排序 快速排序、Shell 排序、归并排序、直接插入排序的关键码比较次数与记录的初始排列有关。折半插入排序、选择排序无关。(直接插入排序在完全有序的情况下每个元素只需要与他左边的元素比较一次就可以确定他最终的位置；折半插入排序，比较次数是固定的，与初始排序无关；快速排序，初始排序不影响每次划分时的比较次数，都要比较n次，但是初始排序会影响划分次数，所以会影响总的比较次数，但快排平均比较次数最小；归并排序在归并的时候，如果右路最小值比左路最大值还大，那么只需要比较n次，如果右路每个元素分别比左路对应位置的元素大，那么需要比较2n-1次，所以与初始排序有关) 精俭排序，即一对数字不进行两次和两次以上的比较，插入和归并是“精俭排序”。插入排序，前面是有序的，后面的每一个元素与前面有序的元素比较，比较过的就是有序的了，不会再比较一次。归并每次合并后，内部都是有序的，内部的元素之间不用再比较。选择排序，每次在后面的元素中找到最小的，找最小元素的过程是在没有排好序的那部分进行，所有肯定会比较多次。堆排序也需比较多次。 外部排序 生成合并段（run）：读入文件的部分记录到内存－&gt;在内存中进行内部排序－&gt;将排好序的这些记录写入外存，形成合并段－&gt;再读入该文件的下面的记录，往复进行，直至文件中的记录全部形成合并段为止。 外部合并：将上一阶段生成的合并段调入内存，进行合并，直至最后形成一个有序的文件。 外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行多路归并排序 不管初始序列是否有序, 冒泡、选择排序时间复杂度是O(n^2),归并、堆排序时间复杂度是O(nlogn） 外部排序的总时间 = 内部排序（产出初始归并段）所需时间 + 外存信息读取时间 + 内部归并所需的时间 外排中使用置换选择排序的目的,是为了增加初始归并段的长度。减少外存读写次数需要减小归并趟数 根据内存容量设若干个输入缓冲区和一个输出缓冲区。若采用二路归并，用两个输入缓冲。 归并的方法类似于归并排序的归并算法。增加的是对缓冲的监视，对于输入，一旦缓冲空，要到相应文件读后续数据，对于输出缓冲，一旦缓冲满，要将缓冲内容写到文件中去。 外排序和内排序不只是考虑内外排序算法的性能，还要考虑IO数据交换效率的问题，内存存取速度远远高于外存。影响外排序的时间因素主要是内存与外设交换信息的总次数 有效的算法设计 贪心法。Dijkstra的最短路径(时间复杂度O(n2))；Prim求最小生成树邻接表存储时是O(n+e),图O(n2)；关键路径及关键活动的求法。 回溯法 分支限界法 分治法。分割、求解、合并。二分查找、归并排序、快速排序。 动态规划。Floyd-Warshall算法求解图中所有点对之间最短路径时间复杂度为O(n3) 动态规划解题的方法是一种高效率的方法，其时间复杂度通常为O(n2)，O(n3)等，可以解决相当大的信息量。（数塔在n&lt;=100层时，可以在很短的时间内得到问题解） 适用的原则：原则为优化原则，即整体优化可以分解为若干个局部优化。 动态规划比穷举法具有较少的计算次数 递归算法需要很大的栈空间，而动态规划不需要栈空间 贪心和动态规划的差别： 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。 在动态规划算法中，每步所作的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能作出选择。而在贪心算法中，仅在当前状态下作出最好选择，即局部最优选择。然后再去解作出这个选择后产生的相应的子问题。 贪心算法所作的贪心选择可以依赖于以往所作过的选择，但决不依赖于将来所作的选择，也不依赖于子问题的解。正是由于这种差别，动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行,以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为一个规模更小的子问题。 P问题 P问题，如果它可以通过运行多项式次(即运行时间至多是输入量大小的多项式函数的一种算法获得解决），可以找到一个能在多项式的时间里解决它的算法。—-确定性问题 NP问题，虽然可以用计算机求解，但是对于任意常数k，它们不能在O(nk)时间内得到解答，可以在多项式的时间里验证一个解的问题。所有的P类问题都是NP问题。 NP完全问题，知道有效的非确定性算法，但是不知道是否存在有效的确定性算法，同时，不能证明这些问题中的任何一个不存在有效的确定性算法。这类问题称为NP完全问题。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jy3321.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://jy3321.github.io/tags/数据结构/"}],"author":"焦洋"},{"title":"Hexo博客搭建","slug":"HexoBlog","date":"2019-07-24T16:00:00.000Z","updated":"2020-10-03T09:36:40.661Z","comments":true,"path":"2019/07/25/HexoBlog/","link":"","permalink":"https://jy3321.github.io/2019/07/25/HexoBlog/","excerpt":"","text":"前言&emsp;&emsp;开始觉得自己搭建一个博客会比较麻烦，现在已有博客平台也已经较为成熟方便，但是在使用了一段时间的现有平台例如CS某N、博某园后不得不吐槽一下，布局千篇一律也就算了，还充斥着各种各样的广告，最后自己实在忍受不了还是决定自己搭一个博客，做到“我的地盘我做主”，没有广告的植入，随心设计，任意管理，也是为了让我能够更好的（装B）书写我的博客文章。在决定自己搭建博客后，我查阅了一些资料，最终决定使用Github+Hexo。 一.为什么选用Github+Hexo 1、全是静态文件，访问速度快； 2、免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 3、可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 4、数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5、博客内容可以轻松打包、转移、发布到其它平台； 6、等等； 二. 准备工作​ 在开始搭建博客之前，你必须做如下准备： 1、安装Git; 2、安装Node.js、npm（关于npm，可以参考https://www.cnblogs.com/goldlong/p/8027997.html）; 3、注册一个github账号; 三.开始搭建github博客创建仓库新建一个名为你的用户名.github.io的仓库，比如说，比如我的github用户名是JY3321，我新建的就是JY3321.github.io的仓库（必须是你的用户名，其它名称无效），将来我的网站访问地址就是 https://jy3321.github.io/了。 如下图为新建，因为我已经建过这样的一个数据仓库了，所以会提示错误 下图为建立好的数据仓库 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里。 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 用git bash执行如下命令： 1$ cd ~/.ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C \"邮件地址\" 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： Title可以随便填写，下面的Key粘贴刚才复制的内容,保存。 测试是否成功： 1$ ssh -T git@github.com # 注意邮箱地址不用改 安装hexo 安装： 1$ npm install -g hexo 初始化：在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\\Workspaces\\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 12$ cd /f/Workspaces/hexo/$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。 hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章： https://jy3321.github.io/2019/08/12/PortOccupancy/#more 第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑… 写博客在我们的hexo根目录下，执行命令： 1hexo new 'my-first-blog' hexo会帮我们在 _posts下生成相关md文件，我们只需要打开这个文件就可以开始写博客了 关于写博客的工具，你可以直接用记事本或者notepad写，但是不方便预览，我自己用的是 Typora，可以实时预览，也很方便，推荐给大家。 通常我们写好博客内容后，只需要 hexo g生成 ， hexo s本地查看 ，hexo d上传，然后就可以在自己github博客，例如我的是 https://jy3321.github.io 看到自己的文章了。如果你觉得使用这个默认域名不够个性，你也可以去阿里云或者其它平台申请一个域名，也不会很贵，进行一些相应的绑定操作就可以拥有自己个性域名的博客了。 四.hexo常用命令常见命令 1234567hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令 12hexo s -g #生成并本地预览hexo d -g #生成并上传 五.常用配置网站基本配置以下配置是站点的全局配置，更多配置，请查看 123456title: JY3321's Blogsubtitle: 网站副标题description: 骄阳焦洋的博客author: 骄阳焦洋language: 网站使用的语言timezone: 网站时区 jsonContent配置详细的配置请查看hexo-generator-json-content 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false 六.注意及其它相关问题注意： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个themes下的； 要注意文章tags的书写格式，多个标签要分行按格格式书写，否则会出现标签显示问题。书写格式如下： 123tags: - Hexo - Indigo *需要注意的是tags后的 - 和 标签 中间有一个空格分隔。 * 其它相关问题可以参考我的其它文章： Hexo博客如何上传图片：https://jy3321.github.io/2019/08/12/HexoPictures/ Hexo博客如何添加评论功能：https://jy3321.github.io/2019/08/12/HexoComments/#more Hexo博客如何更换主题：https://jy3321.github.io/2019/08/13/HexoThemes/#more 参考https://www.jianshu.com/p/e99ed60390a8http://www.cnblogs.com/zhcncn/p/4097881.htmlhttp://www.jianshu.com/p/05289a4bc8b2https://www.jianshu.com/p/eb9009f03178","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://jy3321.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://jy3321.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://jy3321.github.io/tags/GitHub/"}],"author":"焦洋"},{"title":"Hello Word！","slug":"hi-blogs","date":"2019-07-22T16:00:00.000Z","updated":"2019-08-14T03:41:59.871Z","comments":true,"path":"2019/07/23/hi-blogs/","link":"","permalink":"https://jy3321.github.io/2019/07/23/hi-blogs/","excerpt":"","text":"Hello Word！&emsp;&emsp;博客当然也要从一篇Hello Word开始！ &emsp;&emsp;自己在学习的过程中其实一直想记录点什么，学习笔记，或者知识点总结，又或是自己突然冒出的想法。这些事情如果不记录，随着时间的推移，很快就会忘记，而如果有所记录，在某个时刻再去翻看它的时候，不仅能够帮助自己回忆，还能够有别样的感触。 &emsp;&emsp;在博客之前是用印象笔记记了一些杂七杂八的东西，由于这个暑假面临着秋招，自己又要重新复习和总结知识点，紧张有压力的同时也突然莫名的兴奋，像打了鸡血一样想搭建一个自己的博客，边复习边记录一些东西，在几经波折之后，有了现在的这个博客。 &emsp;&emsp;今后将用这个博客来记录自己，可能是学习中的知识总结、可能是编程的技术、也可能是自己的日常或者其它的东西。自己之前确实很迷茫，虚度了很多时间，但是我觉得，只要从当下开始行动，就不算晚。我会通过这个博客，沉淀、积累，并且不断的鞭策自己，认真的对待每一件事情，把每一件事情都去努力做好。 &emsp;&emsp;喜欢的东西很贵，想去的地方很远，要做的工作很难，想给自己爱的人更多，不想辜负别人，更不想负了自己。 &emsp;&emsp;世上没有易事一说，而所谓的难事，其实也没有那么的难。人生苦短，既然来了，就坦荡潇洒的走他一遭。 &emsp;&emsp;那么，焦洋，加油！","categories":[{"name":"Hello Word！","slug":"Hello-Word！","permalink":"https://jy3321.github.io/categories/Hello-Word！/"}],"tags":[{"name":"Hello Word！","slug":"Hello-Word！","permalink":"https://jy3321.github.io/tags/Hello-Word！/"}],"author":"焦洋"}],"categories":[{"name":"IDEA","slug":"IDEA","permalink":"https://jy3321.github.io/categories/IDEA/"},{"name":"学习日记","slug":"学习日记","permalink":"https://jy3321.github.io/categories/学习日记/"},{"name":"Git","slug":"Git","permalink":"https://jy3321.github.io/categories/Git/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://jy3321.github.io/categories/SQL-Server/"},{"name":"日常","slug":"日常","permalink":"https://jy3321.github.io/categories/日常/"},{"name":"数据库","slug":"数据库","permalink":"https://jy3321.github.io/categories/数据库/"},{"name":"UML","slug":"UML","permalink":"https://jy3321.github.io/categories/UML/"},{"name":"Blogs","slug":"Blogs","permalink":"https://jy3321.github.io/categories/Blogs/"},{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/categories/Java/"},{"name":"Java面试题","slug":"Java面试题","permalink":"https://jy3321.github.io/categories/Java面试题/"},{"name":"算法","slug":"算法","permalink":"https://jy3321.github.io/categories/算法/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://jy3321.github.io/categories/计算机网络/"},{"name":"Hexo","slug":"Hexo","permalink":"https://jy3321.github.io/categories/Hexo/"},{"name":"Windows","slug":"Windows","permalink":"https://jy3321.github.io/categories/Windows/"},{"name":"数据结构","slug":"数据结构","permalink":"https://jy3321.github.io/categories/数据结构/"},{"name":"Hello Word！","slug":"Hello-Word！","permalink":"https://jy3321.github.io/categories/Hello-Word！/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://jy3321.github.io/tags/IDEA/"},{"name":"报错","slug":"报错","permalink":"https://jy3321.github.io/tags/报错/"},{"name":"学习日记","slug":"学习日记","permalink":"https://jy3321.github.io/tags/学习日记/"},{"name":"Git","slug":"Git","permalink":"https://jy3321.github.io/tags/Git/"},{"name":"SQL","slug":"SQL","permalink":"https://jy3321.github.io/tags/SQL/"},{"name":"日常","slug":"日常","permalink":"https://jy3321.github.io/tags/日常/"},{"name":"数据库","slug":"数据库","permalink":"https://jy3321.github.io/tags/数据库/"},{"name":"UML","slug":"UML","permalink":"https://jy3321.github.io/tags/UML/"},{"name":"Blogs","slug":"Blogs","permalink":"https://jy3321.github.io/tags/Blogs/"},{"name":"Java","slug":"Java","permalink":"https://jy3321.github.io/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"https://jy3321.github.io/tags/JSP/"},{"name":"面试题","slug":"面试题","permalink":"https://jy3321.github.io/tags/面试题/"},{"name":"算法","slug":"算法","permalink":"https://jy3321.github.io/tags/算法/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://jy3321.github.io/tags/计算机网络/"},{"name":"多线程","slug":"多线程","permalink":"https://jy3321.github.io/tags/多线程/"},{"name":"数据结构","slug":"数据结构","permalink":"https://jy3321.github.io/tags/数据结构/"},{"name":"Stack","slug":"Stack","permalink":"https://jy3321.github.io/tags/Stack/"},{"name":"Heap","slug":"Heap","permalink":"https://jy3321.github.io/tags/Heap/"},{"name":"HTTP","slug":"HTTP","permalink":"https://jy3321.github.io/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://jy3321.github.io/tags/HTTPS/"},{"name":"Hexo","slug":"Hexo","permalink":"https://jy3321.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://jy3321.github.io/tags/GitHub/"},{"name":"Indigo","slug":"Indigo","permalink":"https://jy3321.github.io/tags/Indigo/"},{"name":"Valine","slug":"Valine","permalink":"https://jy3321.github.io/tags/Valine/"},{"name":"Windows","slug":"Windows","permalink":"https://jy3321.github.io/tags/Windows/"},{"name":"Hello Word！","slug":"Hello-Word！","permalink":"https://jy3321.github.io/tags/Hello-Word！/"}]}